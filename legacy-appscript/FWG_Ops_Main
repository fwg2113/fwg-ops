/**
 * ============================================================================
 * FWG OPERATIONS DASHBOARD - Code.gs
 * Frederick Wraps & Graphics - Main Entry Point
 * ============================================================================
 * 
 * This is the central hub for the FWG Dashboard web app.
 * Handles routing, configuration, and core utilities.
 * 
 * Web App URL Parameters:
 *   ?page=dashboard (default) - Main dashboard
 *   ?page=quote&id=XXXXX - Quote detail/edit view
 *   ?page=invoice&id=XXXXX - Invoice detail view
 * 
 * ============================================================================
 */

// ============================================================================
// CONFIGURATION
// ============================================================================

const CONFIG = {
  // Web App URL (deployed)
  webAppUrl: 'https://script.google.com/macros/s/AKfycbywYEttdw_AVHNjJHIbvB0OTRW2RlpNsJ0Uuse5Xz0LaDKLhxT8jAhd0gO0GXOoQhcj/exec',
  
  // Spreadsheets
  specSheetId: '1RvRIcNDsYGvx2to302lzDs3nmFQXHETYNZzMWoyFnhE',
  opsSheetId: '1Pyh1w6Gsx7pkZd9uRwB4YhGQfb0VWHzIE_qzcSO39lw',
  
  // External Spreadsheets (for Command Center metrics)
  fwgInvoicesSheetId: '1hePm-ldfkGeBCQEcrr59RL_3oBiF5b-Ucjmb0GL-_wk',
  financialCoreSheetId: '1dK9v4XosHHHs6eJWHBhhBVtSQKS8_hcZa2uelp3ErBc',
  
  // Google Calendar
  calendarId: 'info@frederickwraps.com',
  
  // Twilio (FWG dedicated number)
  twilio: {
    accountSid: 'x',
    authToken: 'X',
    phoneNumber: '+12406933715',
    messagingServiceSid: '' // Add if using messaging service
  },
  
  // Notifications
  notificationPhone: '+12404158527',
  notificationEmail: 'info@frederickwraps.com',
  
  // Timezone
  timezone: 'America/New_York',
  
  // Sheet names (Operations)
  sheets: {
    submissions: 'Submissions',
    quotes: 'Quotes',
    quoteLineItems: 'QuoteLineItems',
    invoices: 'Invoices',
    invoiceLineItems: 'InvoiceLineItems',
    payments: 'Payments',
    messages: 'Messages',
    tasks: 'Tasks',
    calendarEvents: 'CalendarEvents',
    customers: 'Customers'
  },
  
  // Sheet names (Spec)
  specSheets: {
    vehicleCategories: 'VehicleCategories',
    projectTypes: 'ProjectTypes',
    designScenarios: 'DesignScenarios',
    pricingMatrix: 'PricingMatrix',
    designFees: 'DesignFees',
    materials: 'Materials',
    schedule: 'Schedule',
    closedDates: 'ClosedDates',
    helpers: 'HELPERS'
  }
};

// Status constants
const SUBMISSION_STATUS = {
  NEW: 'New',
  IN_PROGRESS: 'In Progress',
  QUOTED: 'Quoted',
  WON: 'Won',
  LOST: 'Lost',
  ARCHIVED: 'Archived'
};

const QUOTE_STATUS = {
  DRAFT: 'Draft',
  SENT: 'Sent',
  VIEWED: 'Viewed',
  APPROVED: 'Approved',
  DECLINED: 'Declined',
  EXPIRED: 'Expired',
  CONVERTED: 'Converted'
};

const INVOICE_STATUS = {
  DRAFT: 'Draft',
  SENT: 'Sent',
  PARTIAL: 'Partial',
  PAID: 'Paid',
  VOID: 'Void'
};

// NOTE: Task statuses are now managed in FWG_Wraps_Spec → TaskStatuses sheet
// Legacy "Open" tasks will be normalized to "TODO" by the frontend


// ============================================================================
// WEB APP ENTRY POINTS
// ============================================================================

/**
 * Handles GET requests - serves the web app
 */
function doGet(e) {
  const route = e.parameter.route;
  const page = e.parameter.page || 'dashboard';
  
  try {
    // === API ROUTES (return JSON) ===
    if (route === 'new_submission') {
      const result = createSubmission(e.parameter);
      return ContentService.createTextOutput(JSON.stringify(result))
        .setMimeType(ContentService.MimeType.JSON);
    }
    
    if (route === 'bulk_data') {
      const result = {
        ok: true,
        vehicleCategories: getVehicleCategories().categories || [],
        projectTypes: getProjectTypes().types || [],
        designScenarios: getDesignScenarios().scenarios || [],
        pricingMatrix: getPricingMatrix().pricing || [],
        designFees: getDesignFeesMatrix().fees || []
      };
      return ContentService.createTextOutput(JSON.stringify(result))
        .setMimeType(ContentService.MimeType.JSON);
    }
    
    // === PAGE ROUTES (return HTML) ===
    if (page === 'FWG_Ops_Dashboard') {
      return HtmlService.createTemplateFromFile('FWG_Ops_Dashboard')
        .evaluate()
        .setTitle('FWG Operations Dashboard')
        .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL)
        .addMetaTag('viewport', 'width=device-width, initial-scale=1');
    }
    
    // === NEW UNIFIED DOCUMENT ROUTES ===
    if (page === 'document') {
      const template = HtmlService.createTemplateFromFile('FWG_Ops_DocumentDetail');
      template.docId = e.parameter.id || '';
      return template.evaluate()
        .setTitle('FWG Document')
        .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL)
        .addMetaTag('viewport', 'width=device-width, initial-scale=1');
    }
    
    // Customer-facing document page (unified for quotes and invoices)
    if (page === 'customer_document') {
      const template = HtmlService.createTemplateFromFile('FWG_Ops_CustomerDocument');
      template.docId = e.parameter.id || '';
      return template.evaluate()
        .setTitle('Frederick Wraps & Graphics')
        .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL)
        .addMetaTag('viewport', 'width=device-width, initial-scale=1');
    }
    
    // === LEGACY ROUTES (redirect to new unified routes) ===
    if (page === 'quote') {
      const template = HtmlService.createTemplateFromFile('FWG_Ops_DocumentDetail');
      template.docId = e.parameter.id || '';
      return template.evaluate()
        .setTitle('FWG Quote')
        .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL)
        .addMetaTag('viewport', 'width=device-width, initial-scale=1');
    }
    
    if (page === 'invoice') {
      const template = HtmlService.createTemplateFromFile('FWG_Ops_DocumentDetail');
      template.docId = e.parameter.id || '';
      return template.evaluate()
        .setTitle('FWG Invoice')
        .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL)
        .addMetaTag('viewport', 'width=device-width, initial-scale=1');
    }
    
    // Legacy customer-facing routes (redirect to unified)
    if (page === 'customer_quote' || page === 'customer_invoice') {
      const template = HtmlService.createTemplateFromFile('FWG_Ops_CustomerDocument');
      template.docId = e.parameter.id || '';
      return template.evaluate()
        .setTitle('Frederick Wraps & Graphics')
        .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL)
        .addMetaTag('viewport', 'width=device-width, initial-scale=1');
    }
    
    // Default fallback
    return HtmlService.createTemplateFromFile('FWG_Ops_Dashboard')
      .evaluate()
      .setTitle('FWG Operations Dashboard')
      .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
      
  } catch (error) {
    Logger.log('doGet error: ' + error.toString());
    
    // If it was an API route, return JSON error
    if (route) {
      return ContentService.createTextOutput(JSON.stringify({ ok: false, error: error.toString() }))
        .setMimeType(ContentService.MimeType.JSON);
    }
    
    return HtmlService.createHtmlOutput('<h1>Error loading page</h1><p>' + error.toString() + '</p>');
  }
}

/**
 * Handles POST requests - API endpoints for external integrations
 */
function doPost(e) {
  // DEBUG: Log immediately at start of doPost
  const debugSheet = SpreadsheetApp.openById('1Pyh1w6Gsx7pkZd9uRwB4YhGQfb0VWHzIE_qzcSO39lw').getSheetByName('Messages');
  debugSheet.appendRow(['DEBUG-START', new Date().toISOString(), 'doPost called', JSON.stringify(e.parameter || {}).substring(0, 200), JSON.stringify(e.postData || {}).substring(0, 200)]);
  
  try {
    // Detect Twilio incoming SMS FIRST (before JSON parsing which fails on form data)
    if (e.parameter && e.parameter.MessageSid && e.parameter.From) {
      const result = handleIncomingSMS(e);
      return ContentService.createTextOutput(result)
        .setMimeType(ContentService.MimeType.XML);
    }
    
    let data;
    if (e.postData && e.postData.contents) {
      try {
        data = JSON.parse(e.postData.contents);
      } catch (jsonErr) {
        data = e.parameter || {};
      }
    } else {
      data = e.parameter || {};
    }
    
    // Detect Stripe webhook by payload structure (has 'type' and 'data.object')
    if (data.type && data.data && data.data.object) {
      debugSheet.appendRow(['DEBUG-STRIPE', new Date().toISOString(), 'Stripe event detected', data.type, JSON.stringify(data.data.object).substring(0, 200)]);
      const result = handleStripeWebhook(e);
      return ContentService.createTextOutput(JSON.stringify(result))
        .setMimeType(ContentService.MimeType.JSON);
    }
    
    const route = data.route || (e.parameter && e.parameter.route);
    
    // Route: New submission from estimator
    if (route === 'new_submission') {
      const result = createSubmission(data);
      return ContentService.createTextOutput(JSON.stringify(result))
        .setMimeType(ContentService.MimeType.JSON);
    }
    
    // Route: Stripe webhook for payment confirmation
    if (route === 'stripe_webhook') {
      const result = handleStripeWebhook(e);
      return ContentService.createTextOutput(JSON.stringify(result))
        .setMimeType(ContentService.MimeType.JSON);
    }
    
    // Route: File upload
    if (data.action === 'uploadFile') {
      const result = uploadFileFromPost(data);
      return ContentService.createTextOutput(JSON.stringify(result))
        .setMimeType(ContentService.MimeType.JSON);
    }
    
    return ContentService.createTextOutput(JSON.stringify({ ok: false, error: 'Unknown route' }))
      .setMimeType(ContentService.MimeType.JSON);
      
  } catch (error) {
    debugSheet.appendRow(['DEBUG-ERROR', new Date().toISOString(), error.toString()]);
    return ContentService.createTextOutput(JSON.stringify({ ok: false, error: error.toString() }))
      .setMimeType(ContentService.MimeType.JSON);
  }
}


// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

/**
 * Include HTML files (for templates)
 */
function include(filename) {
  return HtmlService.createHtmlOutputFromFile(filename).getContent();
}

/**
 * Get HELPERS value from spec sheet
 */
function getHelper(key) {
  const ss = SpreadsheetApp.openById(CONFIG.specSheetId);
  const sheet = ss.getSheetByName(CONFIG.specSheets.helpers);
  const data = sheet.getDataRange().getValues();
  
  for (let i = 1; i < data.length; i++) {
    if (data[i][0] === key) {
      return data[i][1];
    }
  }
  return null;
}

/**
 * Set HELPERS value in spec sheet
 */
function setHelper(key, value) {
  const ss = SpreadsheetApp.openById(CONFIG.specSheetId);
  const sheet = ss.getSheetByName(CONFIG.specSheets.helpers);
  const data = sheet.getDataRange().getValues();
  
  for (let i = 1; i < data.length; i++) {
    if (data[i][0] === key) {
      sheet.getRange(i + 1, 2).setValue(value);
      return true;
    }
  }
  return false;
}

/**
 * Generate next ID with format YYMMDD-###
 */
function generateId(prefix, counterKey) {
  const now = new Date();
  const dateStr = Utilities.formatDate(now, CONFIG.timezone, 'yyMMdd');
  
  // Get and increment counter
  const props = PropertiesService.getScriptProperties();
  const lastDateKey = counterKey + '_DATE';
  const lastDate = props.getProperty(lastDateKey) || '';
  
  let counter = 1;
  if (lastDate === dateStr) {
    counter = parseInt(props.getProperty(counterKey) || '0') + 1;
  }
  
  props.setProperty(lastDateKey, dateStr);
  props.setProperty(counterKey, counter.toString());
  
  return dateStr + '-' + counter.toString().padStart(3, '0');
}

/**
 * Format phone number consistently: xxx-xxx-xxxx
 */
function formatPhone(phone) {
  if (!phone) return '';
  const digits = String(phone).replace(/\D/g, '');
  if (digits.length === 10) {
    return digits.replace(/(\d{3})(\d{3})(\d{4})/, '$1-$2-$3');
  }
  if (digits.length === 11 && digits.startsWith('1')) {
    return digits.slice(1).replace(/(\d{3})(\d{3})(\d{4})/, '$1-$2-$3');
  }
  return phone;
}

/**
 * Format currency
 */
function formatCurrency(amount) {
  return '$' + Number(amount || 0).toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
}

/**
 * Get current timestamp in EST
 */
function now() {
  return Utilities.formatDate(new Date(), CONFIG.timezone, "yyyy-MM-dd HH:mm:ss");
}

/**
 * Parse sheet data into array of objects using headers
 */
function sheetToObjects(sheetName, spreadsheetId) {
  const ss = SpreadsheetApp.openById(spreadsheetId || CONFIG.opsSheetId);
  const sheet = ss.getSheetByName(sheetName);
  
  if (!sheet) {
    Logger.log('Sheet not found: ' + sheetName);
    return [];
  }
  
  const data = sheet.getDataRange().getValues();
  if (data.length < 2) return [];
  
  const headers = data[0];
  const objects = [];
  
  for (let i = 1; i < data.length; i++) {
    const obj = {};
    headers.forEach((header, j) => {
      obj[header] = data[i][j];
    });
    objects.push(obj);
  }
  
  return objects;
}

/**
 * Find row index by ID in first column
 */
function findRowById(sheetName, id, spreadsheetId) {
  const ss = SpreadsheetApp.openById(spreadsheetId || CONFIG.opsSheetId);
  const sheet = ss.getSheetByName(sheetName);
  const data = sheet.getRange('A:A').getValues();
  
  for (let i = 1; i < data.length; i++) {
    if (data[i][0] === id) {
      return i + 1; // 1-indexed row number
    }
  }
  return -1;
}


// ============================================================================
// DASHBOARD DATA FUNCTIONS (called from frontend)
// ============================================================================

/**
 * Get dashboard summary data
 */
function getDashboardSummary() {
  Logger.log('getDashboardSummary called from web');
  try {
    const submissions = sheetToObjects(CONFIG.sheets.submissions) || [];
    const documents = sheetToObjects('Documents') || [];
    const tasks = sheetToObjects(CONFIG.sheets.tasks) || [];
    
    // Separate quotes and invoices from unified Documents sheet
    const quotes = documents.filter(d => d.doc_type === 'quote');
    const invoices = documents.filter(d => d.doc_type === 'invoice');
    
    // Count by status
    const newSubmissions = submissions.filter(s => s.status === SUBMISSION_STATUS.NEW).length;
    const inProgressSubmissions = submissions.filter(s => s.status === SUBMISSION_STATUS.IN_PROGRESS).length;
    const pendingQuotes = quotes.filter(q => q.status === 'Sent' || q.status === 'Viewed').length;
    const unpaidInvoices = invoices.filter(i => i.status === 'Sent' || i.status === 'Viewed' || i.status === 'Partial').length;
    const openTasks = tasks.filter(t => t.status === 'Open' || t.status === 'TODO').length;
    
    // Calculate revenue this month
    const now = new Date();
    const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);
    const paidThisMonth = invoices
      .filter(i => i.status === 'Paid' && new Date(i.paid_at) >= monthStart)
      .reduce((sum, i) => sum + Number(i.total || 0), 0);
    
    // Pipeline by bucket (for all non-archived documents)
    const activeBuckets = ['READY_FOR_ACTION', 'WAITING_ON_CUSTOMER', 'COLD', '', null, undefined];
    
    // Helper to infer bucket for legacy docs
    function inferBucket(doc) {
      if (doc.bucket) return doc.bucket;
      if (doc.status === 'Paid') return 'ARCHIVE_WON';
      if (doc.status === 'Void' || doc.status === 'Declined' || doc.status === 'Expired') return 'ARCHIVE_LOST';
      if (doc.status === 'Sent' || doc.status === 'Viewed') return 'WAITING_ON_CUSTOMER';
      return 'READY_FOR_ACTION';
    }
    
    // Count documents by bucket
    const pipeline = {
      quotes: {
        readyForAction: quotes.filter(q => inferBucket(q) === 'READY_FOR_ACTION').length,
        waitingOnCustomer: quotes.filter(q => inferBucket(q) === 'WAITING_ON_CUSTOMER').length,
        cold: quotes.filter(q => inferBucket(q) === 'COLD').length,
        totalActive: 0,
        totalValue: 0
      },
      invoices: {
        readyForAction: invoices.filter(i => inferBucket(i) === 'READY_FOR_ACTION').length,
        waitingOnCustomer: invoices.filter(i => inferBucket(i) === 'WAITING_ON_CUSTOMER').length,
        cold: invoices.filter(i => inferBucket(i) === 'COLD').length,
        totalActive: 0,
        totalValue: 0,
        totalUnpaidValue: 0
      }
    };
    
    // Calculate totals
    pipeline.quotes.totalActive = pipeline.quotes.readyForAction + pipeline.quotes.waitingOnCustomer + pipeline.quotes.cold;
    pipeline.invoices.totalActive = pipeline.invoices.readyForAction + pipeline.invoices.waitingOnCustomer + pipeline.invoices.cold;
    
    // Calculate value of active quotes
    pipeline.quotes.totalValue = quotes
      .filter(q => {
        const bucket = inferBucket(q);
        return bucket === 'READY_FOR_ACTION' || bucket === 'WAITING_ON_CUSTOMER' || bucket === 'COLD';
      })
      .reduce((sum, q) => sum + Number(q.total || 0), 0);
    
    // Calculate value of active/unpaid invoices
    pipeline.invoices.totalValue = invoices
      .filter(i => {
        const bucket = inferBucket(i);
        return bucket === 'READY_FOR_ACTION' || bucket === 'WAITING_ON_CUSTOMER' || bucket === 'COLD';
      })
      .reduce((sum, i) => sum + Number(i.total || 0), 0);
    
    pipeline.invoices.totalUnpaidValue = invoices
      .filter(i => i.status !== 'Paid' && i.status !== 'Void')
      .reduce((sum, i) => sum + Number(i.balance_due || 0), 0);
    
    // Documents needing follow-up (in WAITING for 3+ days)
    const threeDaysAgo = new Date();
    threeDaysAgo.setDate(threeDaysAgo.getDate() - 3);
    
    const needsFollowUp = documents.filter(d => {
      const bucket = inferBucket(d);
      if (bucket !== 'WAITING_ON_CUSTOMER') return false;
      const lastContact = new Date(d.last_followup_at || d.sent_at || d.created_at);
      return lastContact < threeDaysAgo;
    }).length;
    
    // Approved quotes needing action
    const approvedQuotes = quotes.filter(q => q.status === 'Approved').length;
    
    // Viewed quotes (customer saw but hasn't acted)
    const viewedQuotes = quotes.filter(q => q.status === 'Viewed').length;
    
    return {
      ok: true,
      summary: {
        newSubmissions,
        inProgressSubmissions,
        pendingQuotes,
        unpaidInvoices,
        openTasks,
        paidThisMonth,
        pipeline,
        needsFollowUp,
        approvedQuotes,
        viewedQuotes
      }
    };
    
  } catch (error) {
    Logger.log('getDashboardSummary error: ' + error.toString());
    return { ok: true, summary: { newSubmissions: 0, inProgressSubmissions: 0, pendingQuotes: 0, unpaidInvoices: 0, openTasks: 0, paidThisMonth: 0, pipeline: null, needsFollowUp: 0, approvedQuotes: 0, viewedQuotes: 0 } };
  }
}

/**
 * Get Command Center metrics for dashboard
 * Pulls FWG revenue data from Financial Core TRANSACTIONS
 * Returns: MTD totals, category breakdown, bonus calculations
 */
function getCommandCenterMetrics() {
  Logger.log('getCommandCenterMetrics called');
  try {
    const now = new Date();
    const currentMonth = now.getMonth();
    const currentYear = now.getFullYear();
    
    // Categories that count toward Diogo/Mason 2.5% bonus
    const BONUS_CATEGORIES = [
      'PPF Revenue',
      'Full Wrap Revenue',
      'Partial Wrap Revenue',
      'Vinyl Lettering Revenue',
      'Vinyl Graphics Revenue'
    ];
    
    // Map Financial Core categories to display labels
    const CATEGORY_DISPLAY = {
      'PPF Revenue': 'PPF',
      'Full Wrap Revenue': 'Full Wrap',
      'Partial Wrap Revenue': 'Partial Wrap',
      'Vinyl Lettering Revenue': 'Vinyl Lettering',
      'Vinyl Graphics Revenue': 'Vinyl Graphics',
      'Apparel Revenue': 'Apparel',
      'Embroidery Revenue': 'Embroidery',
      'Signage Revenue': 'Signage',
      'Stickers Revenue': 'Stickers',
      'Labels Revenue': 'Labels',
      'Design Fee Revenue': 'Design Fee',
      'DTF Transfer Revenue': 'DTF Transfer',
      'Window Graphics Revenue': 'Window Graphics',
      'Other Revenue': 'Other'
    };
    
    // Initialize result structure
    const result = {
      ok: true,
      timestamp: now.toISOString(),
      currentMonth: currentMonth + 1,
      currentYear: currentYear,
      
      // FWG Revenue Metrics
      fwgMtdTotal: 0,
      fwgYtdTotal: 0,
      
      // Bonus-eligible MTD (PPF + Wraps + Vinyl)
      bonusEligibleMtd: 0,
      
      // Individual category MTD for display (uses display labels)
      categoryMtd: {},
      
      // All categories for breakdown display
      categories: {},
      
      // Action items from FWG Ops
      actionItems: {
        newSubmissions: 0,
        approvedQuotes: 0,
        viewedQuotes: 0,
        revisionRequests: 0,
        unpaidInvoices: 0
      }
    };
    
    // =========================================================================
    // PART 1: Get FWG Revenue from Financial Core TRANSACTIONS
    // =========================================================================
    try {
      const fcSS = SpreadsheetApp.openById(CONFIG.financialCoreSheetId);
      const txnSheet = fcSS.getSheetByName('TRANSACTIONS');
      
      if (txnSheet && txnSheet.getLastRow() > 1) {
        const txnData = txnSheet.getRange(2, 1, txnSheet.getLastRow() - 1, 18).getValues();
        
        // Columns based on TRANSACTIONS structure:
        // A:TransactionID, B:Date, C:Business, D:Direction, E:EventType, 
        // F:Amount, G:Account, H:Category, I:ServiceLine, ...
        const COL_DATE = 1;
        const COL_BUSINESS = 2;
        const COL_DIRECTION = 3;
        const COL_AMOUNT = 5;
        const COL_CATEGORY = 7;
        
        txnData.forEach(row => {
          const business = String(row[COL_BUSINESS] || '').trim();
          const direction = String(row[COL_DIRECTION] || '').trim();
          
          // Only count FWG incoming revenue
          if (business !== 'FWG' || direction !== 'IN') return;
          
          const dateVal = row[COL_DATE];
          if (!dateVal) return;
          
          const date = new Date(dateVal);
          const txnMonth = date.getMonth();
          const txnYear = date.getFullYear();
          
          // Only count current year data
          if (txnYear !== currentYear) return;
          
          const category = String(row[COL_CATEGORY] || '').trim();
          const amount = parseCurrencyValue_(row[COL_AMOUNT]);
          
          if (!category || amount <= 0) return;
          
          // Initialize category if needed
          if (!result.categories[category]) {
            result.categories[category] = { mtd: 0, ytd: 0 };
          }
          
          // YTD - all current year
          result.categories[category].ytd += amount;
          result.fwgYtdTotal += amount;
          
          // MTD - current month only
          if (txnMonth === currentMonth) {
            result.categories[category].mtd += amount;
            result.fwgMtdTotal += amount;
            
            // Track category MTD for display (use display label)
            const displayLabel = CATEGORY_DISPLAY[category] || category.replace(' Revenue', '');
            if (!result.categoryMtd[displayLabel]) {
              result.categoryMtd[displayLabel] = 0;
            }
            result.categoryMtd[displayLabel] += amount;
            
            // Track bonus-eligible revenue
            if (BONUS_CATEGORIES.includes(category)) {
              result.bonusEligibleMtd += amount;
            }
          }
        });
      }
      
    } catch (fcError) {
      Logger.log('Error fetching Financial Core data: ' + fcError.toString());
    }
    
    // =========================================================================
    // PART 2: Get Action Items from FWG Ops
    // =========================================================================
    try {
      const submissions = sheetToObjects(CONFIG.sheets.submissions) || [];
      const documents = sheetToObjects('Documents', CONFIG.opsSheetId) || [];
      
      // Count submissions needing attention
      result.actionItems.newSubmissions = submissions.filter(s => 
        s.status === SUBMISSION_STATUS.NEW
      ).length;
      
      // Count quotes by status
      const quotes = documents.filter(d => d.doc_type === 'quote');
      result.actionItems.approvedQuotes = quotes.filter(q => 
        q.status === 'Approved'
      ).length;
      result.actionItems.viewedQuotes = quotes.filter(q => 
        q.status === 'Viewed'
      ).length;
      
      // Count unpaid invoices
      const invoices = documents.filter(d => d.doc_type === 'invoice');
      result.actionItems.unpaidInvoices = invoices.filter(i => 
        i.status === 'Sent' || i.status === 'Viewed' || i.status === 'Partial'
      ).length;
      
    } catch (opsError) {
      Logger.log('Error fetching FWG Ops action items: ' + opsError.toString());
    }
    
    // =========================================================================
    // PART 3: Calculate 2.5% Bonus (Diogo/Mason each)
    // =========================================================================
    result.bonus25Pct = result.bonusEligibleMtd * 0.025;
    
    return result;
    
  } catch (error) {
    Logger.log('getCommandCenterMetrics error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Helper to parse currency values (handles $1,234.56 format)
 */
function parseCurrencyValue_(value) {
  if (typeof value === 'number') return value;
  if (typeof value === 'string') {
    return parseFloat(value.replace(/[\$,]/g, '')) || 0;
  }
  return 0;
}

/**
 * Get all submissions with optional filters
 */
function getSubmissions(filters) {
  Logger.log('getSubmissions called from web');
  try {
    let submissions = sheetToObjects(CONFIG.sheets.submissions) || [];
    
    // Apply filters
    if (filters) {
      if (filters.status) {
        submissions = submissions.filter(s => s.status === filters.status);
      }
      if (filters.search) {
        const search = filters.search.toLowerCase();
        submissions = submissions.filter(s => 
          (s.customer_name || '').toLowerCase().includes(search) ||
          (s.company_name || '').toLowerCase().includes(search) ||
          (s.customer_email || '').toLowerCase().includes(search) ||
          (s.customer_phone || '').toString().includes(search)
        );
      }
    }
    
    // Sort by created_at descending (newest first)
    submissions.sort((a, b) => new Date(b.created_at || 0) - new Date(a.created_at || 0));
    
    // Convert Date objects to strings (google.script.run can't serialize Dates)
    submissions = submissions.map(s => {
      const clean = {};
      for (const key in s) {
        if (s[key] instanceof Date) {
          clean[key] = s[key].toISOString();
        } else {
          clean[key] = s[key];
        }
      }
      return clean;
    });
    
    return { ok: true, submissions: submissions };
    
  } catch (error) {
    Logger.log('getSubmissions error: ' + error.toString());
    return { ok: true, submissions: [] };
  }
}

/**
 * Get single submission by ID
 */
function getSubmission(submissionId) {
  try {
    const submissions = sheetToObjects(CONFIG.sheets.submissions);
    const submission = submissions.find(s => s.submission_id === submissionId);
    
    if (!submission) {
      return { ok: false, error: 'Submission not found' };
    }
    
    // Convert Date objects to strings (google.script.run can't serialize Dates)
    const clean = {};
    for (const key in submission) {
      if (submission[key] instanceof Date) {
        clean[key] = submission[key].toISOString();
      } else {
        clean[key] = submission[key];
      }
    }
    
    return { ok: true, submission: clean };
    
  } catch (error) {
    Logger.log('getSubmission error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Update submission status
 */
function updateSubmissionStatus(submissionId, newStatus) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const sheet = ss.getSheetByName(CONFIG.sheets.submissions);
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    
    const statusCol = headers.indexOf('status') + 1;
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][0] === submissionId) {
        sheet.getRange(i + 1, statusCol).setValue(newStatus);
        Logger.log('Updated submission ' + submissionId + ' to status: ' + newStatus);
        return { ok: true };
      }
    }
    
    return { ok: false, error: 'Submission not found' };
    
  } catch (error) {
    Logger.log('updateSubmissionStatus error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Get unread message count
 */
function getUnreadMessageCount() {
  try {
    const messages = sheetToObjects(CONFIG.sheets.messages);
    const unread = messages.filter(m => 
      m.direction === 'inbound' && 
      (m.read === false || m.read === 'FALSE' || m.read === '')
    ).length;
    
    return { ok: true, count: unread };
    
  } catch (error) {
    Logger.log('getUnreadMessageCount error: ' + error.toString());
    return { ok: false, error: error.toString(), count: 0 };
  }
}

/**
 * Get open task count
 */
function getOpenTaskCount() {
  try {
    const tasks = sheetToObjects(CONFIG.sheets.tasks);
    const open = tasks.filter(t => t.status === TASK_STATUS.OPEN).length;
    
    return { ok: true, count: open };
    
  } catch (error) {
    Logger.log('getOpenTaskCount error: ' + error.toString());
    return { ok: false, error: error.toString(), count: 0 };
  }
}


// ============================================================================
// SPEC DATA FUNCTIONS (for estimator and dropdowns)
// ============================================================================

/**
 * Get vehicle categories
 */
function getVehicleCategories() {
  try {
    const categories = sheetToObjects(CONFIG.specSheets.vehicleCategories, CONFIG.specSheetId)
      .filter(c => c.active === true || c.active === 'TRUE')
      .sort((a, b) => a.sort_order - b.sort_order);
    
    return { ok: true, categories };
    
  } catch (error) {
    Logger.log('getVehicleCategories error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Get project types
 */
function getProjectTypes() {
  try {
    const types = sheetToObjects(CONFIG.specSheets.projectTypes, CONFIG.specSheetId)
      .filter(t => t.active === true || t.active === 'TRUE')
      .sort((a, b) => a.sort_order - b.sort_order);
    
    return { ok: true, types };
    
  } catch (error) {
    Logger.log('getProjectTypes error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Get design scenarios
 */
function getDesignScenarios() {
  try {
    const scenarios = sheetToObjects(CONFIG.specSheets.designScenarios, CONFIG.specSheetId)
      .filter(s => s.active === true || s.active === 'TRUE')
      .sort((a, b) => a.sort_order - b.sort_order);
    
    return { ok: true, scenarios };
    
  } catch (error) {
    Logger.log('getDesignScenarios error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Get pricing for a vehicle category + project type combination
 */
function getPricing(categoryKey, projectKey) {
  try {
    const pricing = sheetToObjects(CONFIG.specSheets.pricingMatrix, CONFIG.specSheetId);
    const match = pricing.find(p => p.category_key === categoryKey && p.project_key === projectKey);
    
    if (!match) {
      return { ok: false, error: 'Pricing not found for this combination' };
    }
    
    return { 
      ok: true, 
      pricing: {
        min: match.price_min,
        max: match.price_max,
        typical: match.typical_price
      }
    };
    
  } catch (error) {
    Logger.log('getPricing error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Get full pricing matrix for estimator
 */
function getPricingMatrix() {
  try {
    const pricing = sheetToObjects(CONFIG.specSheets.pricingMatrix, CONFIG.specSheetId);
    return { ok: true, pricing };
  } catch (error) {
    Logger.log('getPricingMatrix error: ' + error.toString());
    return { ok: false, error: error.toString(), pricing: [] };
  }
}

/**
 * Get full design fees matrix for estimator
 */
function getDesignFeesMatrix() {
  try {
    const fees = sheetToObjects(CONFIG.specSheets.designFees, CONFIG.specSheetId);
    return { ok: true, fees };
  } catch (error) {
    Logger.log('getDesignFeesMatrix error: ' + error.toString());
    return { ok: false, error: error.toString(), fees: [] };
  }
}

/**
 * Get quote/invoice builder configuration
 */
function getQuoteBuilderConfig() {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.specSheetId);
    
    // Get Categories
    const catSheet = ss.getSheetByName('Categories');
    let categories = [];
    if (catSheet) {
      const catData = catSheet.getDataRange().getValues();
      if (catData.length > 1) {
        const headers = catData[0];
        for (let i = 1; i < catData.length; i++) {
          const cat = {};
          headers.forEach((h, col) => {
            cat[h] = catData[i][col];
          });
          if (cat.active !== false) {
            categories.push(cat);
          }
        }
      }
    }
    
    // Get Packages
    const pkgSheet = ss.getSheetByName('Packages');
    let packages = [];
    if (pkgSheet) {
      const pkgData = pkgSheet.getDataRange().getValues();
      if (pkgData.length > 1) {
        const headers = pkgData[0];
        for (let i = 1; i < pkgData.length; i++) {
          const pkg = {};
          headers.forEach((h, col) => {
            pkg[h] = pkgData[i][col];
          });
          if (pkg.active !== false) {
            packages.push(pkg);
          }
        }
      }
    }
    
    // Get LineItemTemplates
    const tmpSheet = ss.getSheetByName('LineItemTemplates');
    let templates = [];
    if (tmpSheet) {
      const tmpData = tmpSheet.getDataRange().getValues();
      if (tmpData.length > 1) {
        const headers = tmpData[0];
        for (let i = 1; i < tmpData.length; i++) {
          const tmp = {};
          headers.forEach((h, col) => {
            tmp[h] = tmpData[i][col];
          });
          if (tmp.active !== false) {
            templates.push(tmp);
          }
        }
      }
    }
    
    // Get LineItemTypes
    const litSheet = ss.getSheetByName('LineItemTypes');
    let lineItemTypes = [];
    if (litSheet) {
      const litData = litSheet.getDataRange().getValues();
      if (litData.length > 1) {
        const headers = litData[0];
        for (let i = 1; i < litData.length; i++) {
          const lit = {};
          headers.forEach((h, col) => {
            lit[h] = litData[i][col];
          });
          if (lit.active === true || lit.active === 'TRUE') {
            lineItemTypes.push(lit);
          }
        }
      }
    }
    
    // Get FeeTypes
    const feeTypesSheet = ss.getSheetByName('FeeTypes');
    let feeTypes = [];
    if (feeTypesSheet) {
      const ftData = feeTypesSheet.getDataRange().getValues();
      if (ftData.length > 1) {
        const headers = ftData[0];
        for (let i = 1; i < ftData.length; i++) {
          const ft = {};
          headers.forEach((h, col) => {
            ft[h] = ftData[i][col];
          });
          if (ft.active === true || ft.active === 'TRUE') {
            feeTypes.push(ft);
          }
        }
      }
    }
    
    Logger.log('getQuoteBuilderConfig: ' + categories.length + ' categories, ' + packages.length + ' packages, ' + templates.length + ' templates, ' + lineItemTypes.length + ' lineItemTypes, ' + feeTypes.length + ' feeTypes');
    
    // Sanitize dates for JSON serialization
    function sanitize(arr) {
      return arr.map(obj => {
        const clean = {};
        for (const key in obj) {
          if (obj[key] instanceof Date) {
            clean[key] = obj[key].toISOString();
          } else {
            clean[key] = obj[key];
          }
        }
        return clean;
      });
    }
    
    return {
      ok: true,
      categories: sanitize(categories),
      packages: sanitize(packages),
      templates: sanitize(templates),
      lineItemTypes: sanitize(lineItemTypes),
      feeTypes: sanitize(feeTypes)
    };
    
  } catch (error) {
    Logger.log('getQuoteBuilderConfig error: ' + error.toString());
    return { ok: false, error: error.toString(), categories: [], packages: [], templates: [] };
  }
}

/**
 * Get design fee for a vehicle category + design scenario combination
 */
function getDesignFee(categoryKey, scenarioKey) {
  try {
    const fees = sheetToObjects(CONFIG.specSheets.designFees, CONFIG.specSheetId);
    const match = fees.find(f => f.category_key === categoryKey && f.scenario_key === scenarioKey);
    
    if (!match) {
      return { ok: true, fee: { min: 0, max: 0, typical: 0 } }; // No fee scenarios
    }
    
    return { 
      ok: true, 
      fee: {
        min: match.design_fee_min,
        max: match.design_fee_max,
        typical: match.typical_fee
      }
    };
    
  } catch (error) {
    Logger.log('getDesignFee error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}


// ============================================================================
// TEST FUNCTIONS
// ============================================================================

/**
 * Test spreadsheet connections
 */
function TEST_connections() {
  Logger.log('=== Testing FWG Dashboard Connections ===');
  Logger.log('');
  
  // Test Spec sheet
  try {
    const specSS = SpreadsheetApp.openById(CONFIG.specSheetId);
    Logger.log('✓ Spec spreadsheet: ' + specSS.getName());
    
    const helpers = sheetToObjects(CONFIG.specSheets.helpers, CONFIG.specSheetId);
    Logger.log('  HELPERS rows: ' + helpers.length);
  } catch (e) {
    Logger.log('✗ Spec spreadsheet error: ' + e.toString());
  }
  
  // Test Ops sheet
  try {
    const opsSS = SpreadsheetApp.openById(CONFIG.opsSheetId);
    Logger.log('✓ Operations spreadsheet: ' + opsSS.getName());
    
    const submissions = sheetToObjects(CONFIG.sheets.submissions);
    Logger.log('  Submissions rows: ' + submissions.length);
  } catch (e) {
    Logger.log('✗ Operations spreadsheet error: ' + e.toString());
  }
  
  // Test Calendar
  try {
    const cal = CalendarApp.getCalendarById(CONFIG.calendarId);
    Logger.log('✓ Calendar: ' + (cal ? cal.getName() : 'Not found'));
  } catch (e) {
    Logger.log('✗ Calendar error: ' + e.toString());
  }
  
  Logger.log('');
  Logger.log('=== Connection Test Complete ===');
}

/**
 * Test ID generation
 */
function TEST_generateId() {
  const subId = generateId('SUB', 'SUBMISSION_COUNTER');
  const quoteId = generateId('Q', 'QUOTE_COUNTER');
  const invId = generateId('INV', 'INVOICE_COUNTER');
  
  Logger.log('Generated Submission ID: ' + subId);
  Logger.log('Generated Quote ID: ' + quoteId);
  Logger.log('Generated Invoice ID: ' + invId);
}

/**
 * Test dashboard summary
 */
function TEST_dashboardSummary() {
  const result = getDashboardSummary();
  Logger.log('Dashboard Summary:');
  Logger.log(JSON.stringify(result, null, 2));
}

function TEST_doGetSubmission() {
  // Simulate a GET request with submission data
  const mockEvent = {
    parameter: {
      route: 'new_submission',
      source: 'test',
      customer_name: 'Test Customer',
      customer_email: 'test@test.com',
      customer_phone: '2405551234',
      vehicle_category: 'CARGO_VAN_LG',
      project_type: 'FULL_WRAP',
      design_scenario: 'LOGO_VISION',
      price_range_min: '5000',
      price_range_max: '8000'
    }
  };
  
  const result = doGet(mockEvent);
  Logger.log('Response: ' + result.getContent());
}

function TEST_dashboardFunctions() {
  Logger.log('Testing getDashboardSummary...');
  const summary = getDashboardSummary();
  Logger.log('Summary: ' + JSON.stringify(summary));
  
  Logger.log('Testing getSubmissions...');
  const subs = getSubmissions();
  Logger.log('Submissions: ' + JSON.stringify(subs));
  
  Logger.log('Testing getUnreadMessageCount...');
  const msgs = getUnreadMessageCount();
  Logger.log('Messages: ' + JSON.stringify(msgs));
}

function TEST_include() {
  try {
    const result = HtmlService.createTemplateFromFile('Dashboard').evaluate().getContent();
    Logger.log('Dashboard HTML length: ' + result.length);
    Logger.log('First 500 chars: ' + result.substring(0, 500));
  } catch(e) {
    Logger.log('Error: ' + e.toString());
  }
}

function TEST_directCall() {
  // This simulates exactly what google.script.run does
  const result = getDashboardSummary();
  Logger.log('Type: ' + typeof result);
  Logger.log('Result: ' + JSON.stringify(result));
  return result;
}

function testDashboardReturn() {
  // Step 1: Test with tiny object
  return { test: "hello", number: 42 };
}


function getConversationsWrapper() {
  try {
    return getConversations();
  } catch (e) {
    return { ok: false, error: e.toString() };
  }
}

function archiveConversationWrapper(phone) {
  try {
    return archiveConversation(phone);
  } catch (e) {
    return { ok: false, error: e.toString() };
  }
}

function getMessagesByPhoneWrapper(phone) {
  try {
    return getMessagesByPhone(phone);
  } catch (e) {
    return { ok: false, error: e.toString() };
  }
}

function sendSMSWrapper(phone, message, submissionId, quoteId, invoiceId) {
  try {
    return sendSMS(phone, message, submissionId, quoteId, invoiceId);
  } catch (e) {
    return { ok: false, error: e.toString() };
  }
}

function markConversationAsReadWrapper(phone) {
  try {
    return markConversationAsRead(phone);
  } catch (e) {
    return { ok: false, error: e.toString() };
  }
}

function sendMessageToCustomerWrapper(phone, message, context) {
  try {
    return sendMessageToCustomer(phone, message, context);
  } catch (e) {
    return { ok: false, error: e.toString() };
  }
}

function markConversationAsReadWrapper(phone) {
  try {
    return markConversationAsRead(phone);
  } catch (e) {
    return { ok: false, error: e.toString() };
  }
}

// ============================================================================
// CALENDAR FUNCTIONS
// ============================================================================

/**
 * Get calendar events for a date range
 */
function getCalendarEvents(startDate, endDate) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const sheet = ss.getSheetByName(CONFIG.sheets.calendarEvents);
    const data = sheet.getDataRange().getValues();
    
    if (data.length < 2) {
      return { ok: true, events: [] };
    }
    
    const headers = data[0];
    const events = [];
    
    const start = new Date(startDate);
    const end = new Date(endDate);
    start.setHours(0, 0, 0, 0);
    end.setHours(23, 59, 59, 999);
    
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      const obj = {};
      headers.forEach((h, col) => {
        obj[h] = row[col];
      });
      
      // Filter by date range
      const eventStart = new Date(obj.start_time);
      if (eventStart >= start && eventStart <= end && obj.status !== 'Cancelled') {
        // Convert dates to ISO strings for JSON
        obj.start_time = obj.start_time ? new Date(obj.start_time).toISOString() : null;
        obj.end_time = obj.end_time ? new Date(obj.end_time).toISOString() : null;
        obj.created_at = obj.created_at ? new Date(obj.created_at).toISOString() : null;
        events.push(obj);
      }
    }
    
    return { ok: true, events: events };
    
  } catch (error) {
    Logger.log('getCalendarEvents error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Create a calendar event
 */
function createCalendarEvent(eventData) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const sheet = ss.getSheetByName(CONFIG.sheets.calendarEvents);
    
    // Generate event ID
    const eventId = 'EVT-' + Utilities.formatDate(new Date(), 'America/New_York', 'yyMMdd') + '-' + 
                    Math.random().toString(36).substr(2, 5).toUpperCase();
    
    // Create Google Calendar event
    let googleEventId = '';
    try {
      const cal = CalendarApp.getCalendarById(CONFIG.calendarId);
      if (cal) {
        const startTime = new Date(eventData.start_time);
        const endTime = new Date(eventData.end_time);
        
        const gEvent = cal.createEvent(eventData.title, startTime, endTime, {
          description: buildEventDescription(eventData)
        });
        googleEventId = gEvent.getId();
        
        // Set event color based on category
        if (eventData.category_color) {
          const colorId = getCalendarColorId(eventData.category_color);
          if (colorId) {
            gEvent.setColor(colorId);
          }
        }
        
        Logger.log('✓ Google Calendar event created: ' + googleEventId);
      }
    } catch (calError) {
      Logger.log('Google Calendar error (continuing): ' + calError.toString());
    }
    
    // Add to sheet
    sheet.appendRow([
      eventId,
      googleEventId,
      new Date(),
      eventData.event_type || 'Job',
      eventData.title,
      new Date(eventData.start_time),
      new Date(eventData.end_time),
      eventData.customer_name || '',
      eventData.customer_phone || '',
      eventData.vehicle_description || '',
      eventData.submission_id || '',
      eventData.quote_id || '',
      eventData.invoice_id || '',
      'Scheduled',
      eventData.notes || ''
    ]);
    
    Logger.log('✓ Calendar event created: ' + eventId);
    
    return { ok: true, event_id: eventId, google_event_id: googleEventId };
    
  } catch (error) {
    Logger.log('createCalendarEvent error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Update a calendar event
 */
function updateCalendarEvent(eventId, updates) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const sheet = ss.getSheetByName(CONFIG.sheets.calendarEvents);
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    
    let rowIndex = -1;
    let googleEventId = '';
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][0] === eventId) {
        rowIndex = i;
        googleEventId = data[i][1];
        break;
      }
    }
    
    if (rowIndex === -1) {
      return { ok: false, error: 'Event not found' };
    }
    
    // Update sheet
    Object.keys(updates).forEach(key => {
      const colIndex = headers.indexOf(key);
      if (colIndex !== -1) {
        let value = updates[key];
        if (key === 'start_time' || key === 'end_time') {
          value = new Date(value);
        }
        sheet.getRange(rowIndex + 1, colIndex + 1).setValue(value);
      }
    });
    
    // Update Google Calendar event
    if (googleEventId) {
      try {
        const cal = CalendarApp.getCalendarById(CONFIG.calendarId);
        if (cal) {
          const gEvent = cal.getEventById(googleEventId);
          if (gEvent) {
            if (updates.title) gEvent.setTitle(updates.title);
            if (updates.start_time && updates.end_time) {
              gEvent.setTime(new Date(updates.start_time), new Date(updates.end_time));
            }
            Logger.log('✓ Google Calendar event updated');
          }
        }
      } catch (calError) {
        Logger.log('Google Calendar update error (continuing): ' + calError.toString());
      }
    }
    
    Logger.log('✓ Calendar event updated: ' + eventId);
    return { ok: true };
    
  } catch (error) {
    Logger.log('updateCalendarEvent error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Delete/cancel a calendar event
 */
function cancelCalendarEvent(eventId) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const sheet = ss.getSheetByName(CONFIG.sheets.calendarEvents);
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    
    let rowIndex = -1;
    let googleEventId = '';
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][0] === eventId) {
        rowIndex = i;
        googleEventId = data[i][1];
        break;
      }
    }
    
    if (rowIndex === -1) {
      return { ok: false, error: 'Event not found' };
    }
    
    // Mark as cancelled in sheet
    const statusCol = headers.indexOf('status');
    if (statusCol !== -1) {
      sheet.getRange(rowIndex + 1, statusCol + 1).setValue('Cancelled');
    }
    
    // Delete from Google Calendar
    if (googleEventId) {
      try {
        const cal = CalendarApp.getCalendarById(CONFIG.calendarId);
        if (cal) {
          const gEvent = cal.getEventById(googleEventId);
          if (gEvent) {
            gEvent.deleteEvent();
            Logger.log('✓ Google Calendar event deleted');
          }
        }
      } catch (calError) {
        Logger.log('Google Calendar delete error (continuing): ' + calError.toString());
      }
    }
    
    Logger.log('✓ Calendar event cancelled: ' + eventId);
    return { ok: true };
    
  } catch (error) {
    Logger.log('cancelCalendarEvent error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Fully delete a calendar event (removes from sheet AND Google Calendar)
 */
function deleteCalendarEvent(eventId) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const sheet = ss.getSheetByName(CONFIG.sheets.calendarEvents);
    const data = sheet.getDataRange().getValues();
    
    let rowIndex = -1;
    let googleEventId = '';
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][0] === eventId) {
        rowIndex = i;
        googleEventId = data[i][1];
        break;
      }
    }
    
    if (rowIndex === -1) {
      return { ok: false, error: 'Event not found' };
    }
    
    // Delete from Google Calendar first
    if (googleEventId) {
      try {
        const cal = CalendarApp.getCalendarById(CONFIG.calendarId);
        if (cal) {
          const gEvent = cal.getEventById(googleEventId);
          if (gEvent) {
            gEvent.deleteEvent();
            Logger.log('✓ Google Calendar event deleted');
          }
        }
      } catch (calError) {
        Logger.log('Google Calendar delete error (continuing): ' + calError.toString());
      }
    }
    
    // Delete row from sheet
    sheet.deleteRow(rowIndex + 1);
    Logger.log('✓ Calendar event fully deleted: ' + eventId);
    
    return { ok: true };
    
  } catch (error) {
    Logger.log('deleteCalendarEvent error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Build event description for Google Calendar
 */
function buildEventDescription(eventData) {
  let desc = '';
  
  if (eventData.customer_name) desc += 'Customer: ' + eventData.customer_name + '\n';
  if (eventData.customer_phone) desc += 'Phone: ' + eventData.customer_phone + '\n';
  if (eventData.vehicle_description) desc += 'Vehicle: ' + eventData.vehicle_description + '\n';
  if (eventData.quote_id) desc += 'Quote: ' + eventData.quote_id + '\n';
  if (eventData.invoice_id) desc += 'Invoice: ' + eventData.invoice_id + '\n';
  if (eventData.notes) desc += '\nNotes: ' + eventData.notes;
  
  return desc;
}

/**
 * Map hex color to Google Calendar color ID
 * Google Calendar has limited color options (1-11)
 */
function getCalendarColorId(hexColor) {
  if (!hexColor) return null;
  
  const colorMap = {
    '#10B981': '10', // Green (Sage)
    '#22c55e': '10', // Green
    '#3B82F6': '9',  // Blue (Blueberry)
    '#6366F1': '1',  // Indigo (Lavender)
    '#F43F5E': '11', // Red (Tomato)
    '#ef4444': '11', // Red
    '#F97316': '6',  // Orange (Tangerine)
    '#FBBF24': '5',  // Yellow (Banana)
    '#A3E635': '2',  // Lime (Sage)
    '#22D3EE': '7',  // Cyan (Peacock)
    '#64748B': '8',  // Gray (Graphite)
    '#94A3B8': '8',  // Gray
    '#a855f7': '3',  // Purple (Grape)
    '#ec4899': '4'   // Pink (Flamingo)
  };
  
  // Find closest match
  const hex = hexColor.toUpperCase();
  for (const [color, id] of Object.entries(colorMap)) {
    if (color.toUpperCase() === hex) {
      return id;
    }
  }
  
  return '9'; // Default to blue
}

/**
 * Schedule a job from a quote or invoice
 */
function scheduleJob(jobData) {
  try {
    // Build title from job data
    let title = '';
    if (jobData.category_label) {
      title = jobData.category_label + ' - ';
    }
    title += jobData.customer_name || 'Customer';
    if (jobData.vehicle_description) {
      title += ' (' + jobData.vehicle_description + ')';
    }
    
    const eventData = {
      event_type: jobData.event_type || 'Job',
      title: title,
      start_time: jobData.start_time,
      end_time: jobData.end_time,
      customer_name: jobData.customer_name,
      customer_phone: jobData.customer_phone,
      vehicle_description: jobData.vehicle_description,
      submission_id: jobData.submission_id,
      quote_id: jobData.quote_id,
      invoice_id: jobData.invoice_id,
      category_color: jobData.category_color,
      notes: jobData.notes
    };
    
    return createCalendarEvent(eventData);
    
  } catch (error) {
    Logger.log('scheduleJob error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Get calendar events linked to an invoice
 */
function getEventsForInvoice(invoiceId) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const sheet = ss.getSheetByName(CONFIG.sheets.calendarEvents);
    const data = sheet.getDataRange().getValues();
    
    if (data.length < 2) {
      return { ok: true, events: [] };
    }
    
    const headers = data[0];
    const events = [];
    
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      const obj = {};
      headers.forEach((h, col) => {
        obj[h] = row[col];
      });
      
      if (obj.invoice_id === invoiceId && obj.status !== 'Cancelled') {
        obj.start_time = obj.start_time ? new Date(obj.start_time).toISOString() : null;
        obj.end_time = obj.end_time ? new Date(obj.end_time).toISOString() : null;
        obj.created_at = obj.created_at ? new Date(obj.created_at).toISOString() : null;
        events.push(obj);
      }
    }
    
    return { ok: true, events: events };
    
  } catch (error) {
    Logger.log('getEventsForInvoice error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Check if invoices have scheduled events (for list badges)
 */
function getInvoiceScheduleStatus(invoiceIds) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const sheet = ss.getSheetByName(CONFIG.sheets.calendarEvents);
    const data = sheet.getDataRange().getValues();
    
    if (data.length < 2) {
      return { ok: true, status: {} };
    }
    
    const headers = data[0];
    const invoiceIdCol = headers.indexOf('invoice_id');
    const statusCol = headers.indexOf('status');
    const startCol = headers.indexOf('start_time');
    
    const status = {};
    invoiceIds.forEach(id => status[id] = { scheduled: false, nextEvent: null });
    
    for (let i = 1; i < data.length; i++) {
      const invId = data[i][invoiceIdCol];
      const evtStatus = data[i][statusCol];
      const startTime = data[i][startCol];
      
      if (invId && status[invId] !== undefined && evtStatus !== 'Cancelled') {
        status[invId].scheduled = true;
        if (startTime && (!status[invId].nextEvent || new Date(startTime) < new Date(status[invId].nextEvent))) {
          status[invId].nextEvent = new Date(startTime).toISOString();
        }
      }
    }
    
    return { ok: true, status: status };
    
  } catch (error) {
    Logger.log('getInvoiceScheduleStatus error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

// ============================================================================
// TASK SYSTEM - BACKEND FUNCTIONS
// ============================================================================

/**
 * Get all task system configuration (statuses, priorities, templates, automations)
 */
function getTaskSystemConfig() {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.specSheetId);
    
    const taskStatuses = getSheetAsObjects(ss, 'TaskStatuses');
    const taskPriorities = getSheetAsObjects(ss, 'TaskPriorities');
    const projectTemplates = getSheetAsObjects(ss, 'ProjectTemplates');
    const templateTasks = getSheetAsObjects(ss, 'TemplateTasks');
    const automations = getSheetAsObjects(ss, 'Automations');
    const invoiceStatuses = getSheetAsObjects(ss, 'InvoiceStatuses');
    
    // Nest template tasks under their templates
    const templatesWithTasks = projectTemplates.map(t => ({
      ...t,
      tasks: templateTasks
        .filter(task => task.template_key === t.template_key)
        .sort((a, b) => (a.sort_order || 0) - (b.sort_order || 0))
    }));
    
    return {
      ok: true,
      taskStatuses: taskStatuses.sort((a, b) => (a.sort_order || 0) - (b.sort_order || 0)),
      taskPriorities: taskPriorities.sort((a, b) => (a.sort_order || 0) - (b.sort_order || 0)),
      projectTemplates: templatesWithTasks.sort((a, b) => (a.sort_order || 0) - (b.sort_order || 0)),
      automations: automations,
      invoiceStatuses: invoiceStatuses.sort((a, b) => (a.sort_order || 0) - (b.sort_order || 0))
    };
    
  } catch (error) {
    Logger.log('getTaskSystemConfig error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Helper: Get sheet as array of objects
 */
function getSheetAsObjects(ss, sheetName) {
  const sheet = ss.getSheetByName(sheetName);
  if (!sheet) return [];
  
  const data = sheet.getDataRange().getValues();
  if (data.length < 2) return [];
  
  const headers = data[0];
  const objects = [];
  
  // Helper to convert dates to ISO strings
  function sanitizeValue(val) {
    if (val instanceof Date) {
      return val.toISOString();
    }
    return val;
  }
  
  for (let i = 1; i < data.length; i++) {
    const obj = {};
    headers.forEach((h, col) => {
      obj[h] = sanitizeValue(data[i][col]);
    });
    objects.push(obj);
  }
  
  return objects;
}

// -------------------------------------------------------------------------
// TASK STATUSES CRUD
// -------------------------------------------------------------------------

function saveTaskStatus(statusData) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.specSheetId);
    const sheet = ss.getSheetByName('TaskStatuses');
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    
    const keyCol = headers.indexOf('status_key');
    let rowIndex = -1;
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][keyCol] === statusData.status_key) {
        rowIndex = i;
        break;
      }
    }
    
    if (rowIndex === -1) {
      const newRow = headers.map(h => statusData[h] ?? '');
      sheet.appendRow(newRow);
      Logger.log('✓ Task status created: ' + statusData.status_key);
    } else {
      headers.forEach((h, col) => {
        if (statusData[h] !== undefined) {
          sheet.getRange(rowIndex + 1, col + 1).setValue(statusData[h]);
        }
      });
      Logger.log('✓ Task status updated: ' + statusData.status_key);
    }
    
    return { ok: true };
    
  } catch (error) {
    Logger.log('saveTaskStatus error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Get tasks linked to a specific document
 */
function getTasksForDocument(docId, docType) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const sheet = ss.getSheetByName('Tasks');
    
    if (!sheet) {
      return { ok: true, tasks: [] };
    }
    
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    
    // Find column indices
    const colMap = {};
    headers.forEach((h, i) => colMap[h] = i);
    
    const tasks = [];
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      const task = {};
      headers.forEach((h, idx) => task[h] = row[idx]);
      
      // Skip reference/header rows
      if (!task.task_id || task.task_id === 'task_id') continue;
      
      // Check if linked to this document
      let isLinked = false;
      if (docType === 'quote' && task.quote_id && String(task.quote_id) === String(docId)) {
        isLinked = true;
      }
      if (docType === 'invoice' && task.invoice_id && String(task.invoice_id) === String(docId)) {
        isLinked = true;
      }
      
      if (isLinked) {
        // Sanitize dates
        for (const key in task) {
          if (task[key] instanceof Date) {
            task[key] = task[key].toISOString();
          }
        }
        tasks.push(task);
      }
    }
    
    return { ok: true, tasks: tasks };
    
  } catch (error) {
    Logger.log('getTasksForDocument error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Reopen a completed task
 */
function reopenTask(taskId) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const sheet = ss.getSheetByName('Tasks');
    
    if (!sheet) {
      return { ok: false, error: 'Tasks sheet not found' };
    }
    
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    const taskIdCol = headers.indexOf('task_id');
    const statusCol = headers.indexOf('status');
    const completedAtCol = headers.indexOf('completed_at');
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][taskIdCol] === taskId) {
        if (statusCol !== -1) {
          sheet.getRange(i + 1, statusCol + 1).setValue('TODO');
        }
        if (completedAtCol !== -1) {
          sheet.getRange(i + 1, completedAtCol + 1).setValue('');
        }
        
        Logger.log('Task reopened: ' + taskId);
        return { ok: true };
      }
    }
    
    return { ok: false, error: 'Task not found' };
    
  } catch (error) {
    Logger.log('reopenTask error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Mark a task as complete
 */
function completeTask(taskId) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const sheet = ss.getSheetByName('Tasks');
    
    if (!sheet) {
      return { ok: false, error: 'Tasks sheet not found' };
    }
    
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    const taskIdCol = headers.indexOf('task_id');
    const statusCol = headers.indexOf('status');
    const completedAtCol = headers.indexOf('completed_at');
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][taskIdCol] === taskId) {
        // Update status to COMPLETED
        if (statusCol !== -1) {
          sheet.getRange(i + 1, statusCol + 1).setValue('COMPLETED');
        }
        // Set completed_at timestamp
        if (completedAtCol !== -1) {
          sheet.getRange(i + 1, completedAtCol + 1).setValue(new Date().toISOString());
        }
        
        Logger.log('Task completed: ' + taskId);
        return { ok: true };
      }
    }
    
    return { ok: false, error: 'Task not found' };
    
  } catch (error) {
    Logger.log('completeTask error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

function deleteTaskStatus(statusKey) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.specSheetId);
    const sheet = ss.getSheetByName('TaskStatuses');
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    const keyCol = headers.indexOf('status_key');
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][keyCol] === statusKey) {
        sheet.deleteRow(i + 1);
        Logger.log('✓ Task status deleted: ' + statusKey);
        return { ok: true };
      }
    }
    
    return { ok: false, error: 'Status not found' };
    
  } catch (error) {
    Logger.log('deleteTaskStatus error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Get tasks with optional filtering
 * @param {Object} options - { status: 'active'|'completed'|'all' }
 */
function getTasks(options) {
  Logger.log('>>> getTasks called');
  Logger.log('>>> options: ' + JSON.stringify(options));
  try {
    Logger.log('>>> Opening spreadsheet');
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const sheet = ss.getSheetByName('Tasks');
    
    if (!sheet) {
      return { ok: true, tasks: [] };
    }
    
    const data = sheet.getDataRange().getValues();
    if (data.length < 2) {
      return { ok: true, tasks: [] };
    }
    
    const headers = data[0];
    const statusCol = headers.indexOf('status');
    const tasks = [];
    
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      
      // Skip empty rows and reference/documentation rows
      if (!row[0]) continue;
      if (row[0].toString().startsWith('---')) continue;
      if (row[0] === 'Type') continue;
      if (!row[0].toString().match(/^\d{6}-\d{3}$/)) continue; // Only valid task IDs like 260120-001
      
      const task = {};
      headers.forEach((h, col) => {
        task[h] = row[col];
      });
      
      // Filter by status if requested
      if (options && options.status === 'active') {
        const taskStatus = (task.status || '').toUpperCase();
        if (taskStatus === 'COMPLETED' || taskStatus === 'DONE') {
          continue;
        }
      } else if (options && options.status === 'completed') {
        const taskStatus = (task.status || '').toUpperCase();
        if (taskStatus !== 'COMPLETED' && taskStatus !== 'DONE') {
          continue;
        }
      }
      
      tasks.push(task);
    }
    
    // Sort by priority then by due date
    const priorityOrder = { 'URGENT': 1, 'HIGH': 2, 'NORMAL': 3, 'MEDIUM': 3, 'LOW': 4 };
    tasks.sort((a, b) => {
      const aPriority = priorityOrder[(a.priority || 'NORMAL').toUpperCase()] || 3;
      const bPriority = priorityOrder[(b.priority || 'NORMAL').toUpperCase()] || 3;
      if (aPriority !== bPriority) return aPriority - bPriority;
      
      // Then by due date (nulls last)
      if (a.due_date && !b.due_date) return -1;
      if (!a.due_date && b.due_date) return 1;
      if (a.due_date && b.due_date) {
        return new Date(a.due_date) - new Date(b.due_date);
      }
      return 0;
    });
    
    Logger.log('>>> Returning ' + tasks.length + ' tasks');
    
    // Sanitize tasks - convert Date objects to ISO strings
    const sanitizedTasks = tasks.map(task => {
      const clean = {};
      for (const key in task) {
        const val = task[key];
        if (val instanceof Date) {
          clean[key] = val.toISOString();
        } else if (val === undefined) {
          clean[key] = null;
        } else {
          clean[key] = val;
        }
      }
      return clean;
    });
    
    return { ok: true, tasks: sanitizedTasks };
    
  } catch (error) {
    Logger.log('>>> CATCH ERROR: ' + error.toString());
    Logger.log('getTasks error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

// -------------------------------------------------------------------------
// TASK PRIORITIES CRUD
// -------------------------------------------------------------------------

function saveTaskPriority(priorityData) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.specSheetId);
    const sheet = ss.getSheetByName('TaskPriorities');
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    
    const keyCol = headers.indexOf('priority_key');
    let rowIndex = -1;
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][keyCol] === priorityData.priority_key) {
        rowIndex = i;
        break;
      }
    }
    
    if (rowIndex === -1) {
      const newRow = headers.map(h => priorityData[h] ?? '');
      sheet.appendRow(newRow);
      Logger.log('✓ Task priority created: ' + priorityData.priority_key);
    } else {
      headers.forEach((h, col) => {
        if (priorityData[h] !== undefined) {
          sheet.getRange(rowIndex + 1, col + 1).setValue(priorityData[h]);
        }
      });
      Logger.log('✓ Task priority updated: ' + priorityData.priority_key);
    }
    
    return { ok: true };
    
  } catch (error) {
    Logger.log('saveTaskPriority error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

function deleteTaskPriority(priorityKey) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.specSheetId);
    const sheet = ss.getSheetByName('TaskPriorities');
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    const keyCol = headers.indexOf('priority_key');
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][keyCol] === priorityKey) {
        sheet.deleteRow(i + 1);
        Logger.log('✓ Task priority deleted: ' + priorityKey);
        return { ok: true };
      }
    }
    
    return { ok: false, error: 'Priority not found' };
    
  } catch (error) {
    Logger.log('deleteTaskPriority error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

// -------------------------------------------------------------------------
// PROJECT TEMPLATES CRUD
// -------------------------------------------------------------------------

function saveProjectTemplate(templateData) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.specSheetId);
    const sheet = ss.getSheetByName('ProjectTemplates');
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    
    const keyCol = headers.indexOf('template_key');
    let rowIndex = -1;
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][keyCol] === templateData.template_key) {
        rowIndex = i;
        break;
      }
    }
    
    if (rowIndex === -1) {
      const newRow = headers.map(h => templateData[h] ?? '');
      sheet.appendRow(newRow);
      Logger.log('✓ Project template created: ' + templateData.template_key);
    } else {
      headers.forEach((h, col) => {
        if (templateData[h] !== undefined) {
          sheet.getRange(rowIndex + 1, col + 1).setValue(templateData[h]);
        }
      });
      Logger.log('✓ Project template updated: ' + templateData.template_key);
    }
    
    return { ok: true };
    
  } catch (error) {
    Logger.log('saveProjectTemplate error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

function deleteProjectTemplate(templateKey) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.specSheetId);
    
    // Delete template
    let sheet = ss.getSheetByName('ProjectTemplates');
    let data = sheet.getDataRange().getValues();
    let headers = data[0];
    let keyCol = headers.indexOf('template_key');
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][keyCol] === templateKey) {
        sheet.deleteRow(i + 1);
        Logger.log('✓ Project template deleted: ' + templateKey);
        break;
      }
    }
    
    // Also delete associated template tasks
    sheet = ss.getSheetByName('TemplateTasks');
    data = sheet.getDataRange().getValues();
    headers = data[0];
    keyCol = headers.indexOf('template_key');
    
    for (let i = data.length - 1; i >= 1; i--) {
      if (data[i][keyCol] === templateKey) {
        sheet.deleteRow(i + 1);
      }
    }
    Logger.log('✓ Associated template tasks deleted');
    
    return { ok: true };
    
  } catch (error) {
    Logger.log('deleteProjectTemplate error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

// -------------------------------------------------------------------------
// TEMPLATE TASKS CRUD
// -------------------------------------------------------------------------

function saveTemplateTask(taskData) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.specSheetId);
    const sheet = ss.getSheetByName('TemplateTasks');
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    
    const templateKeyCol = headers.indexOf('template_key');
    const taskKeyCol = headers.indexOf('task_key');
    let rowIndex = -1;
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][templateKeyCol] === taskData.template_key && data[i][taskKeyCol] === taskData.task_key) {
        rowIndex = i;
        break;
      }
    }
    
    if (rowIndex === -1) {
      const newRow = headers.map(h => taskData[h] ?? '');
      sheet.appendRow(newRow);
      Logger.log('✓ Template task created: ' + taskData.task_key);
    } else {
      headers.forEach((h, col) => {
        if (taskData[h] !== undefined) {
          sheet.getRange(rowIndex + 1, col + 1).setValue(taskData[h]);
        }
      });
      Logger.log('✓ Template task updated: ' + taskData.task_key);
    }
    
    return { ok: true };
    
  } catch (error) {
    Logger.log('saveTemplateTask error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

function deleteTemplateTask(templateKey, taskKey) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.specSheetId);
    const sheet = ss.getSheetByName('TemplateTasks');
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    const templateKeyCol = headers.indexOf('template_key');
    const taskKeyCol = headers.indexOf('task_key');
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][templateKeyCol] === templateKey && data[i][taskKeyCol] === taskKey) {
        sheet.deleteRow(i + 1);
        Logger.log('✓ Template task deleted: ' + taskKey);
        return { ok: true };
      }
    }
    
    return { ok: false, error: 'Task not found' };
    
  } catch (error) {
    Logger.log('deleteTemplateTask error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

// -------------------------------------------------------------------------
// AUTOMATIONS CRUD
// -------------------------------------------------------------------------

function saveAutomation(automationData) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.specSheetId);
    const sheet = ss.getSheetByName('Automations');
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    
    const keyCol = headers.indexOf('automation_key');
    let rowIndex = -1;
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][keyCol] === automationData.automation_key) {
        rowIndex = i;
        break;
      }
    }
    
    if (rowIndex === -1) {
      const newRow = headers.map(h => automationData[h] ?? '');
      sheet.appendRow(newRow);
      Logger.log('✓ Automation created: ' + automationData.automation_key);
    } else {
      headers.forEach((h, col) => {
        if (automationData[h] !== undefined) {
          sheet.getRange(rowIndex + 1, col + 1).setValue(automationData[h]);
        }
      });
      Logger.log('✓ Automation updated: ' + automationData.automation_key);
    }
    
    return { ok: true };
    
  } catch (error) {
    Logger.log('saveAutomation error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

function deleteAutomation(automationKey) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.specSheetId);
    const sheet = ss.getSheetByName('Automations');
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    const keyCol = headers.indexOf('automation_key');
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][keyCol] === automationKey) {
        sheet.deleteRow(i + 1);
        Logger.log('✓ Automation deleted: ' + automationKey);
        return { ok: true };
      }
    }
    
    return { ok: false, error: 'Automation not found' };
    
  } catch (error) {
    Logger.log('deleteAutomation error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

// -------------------------------------------------------------------------
// INVOICE STATUSES CRUD
// -------------------------------------------------------------------------

function saveInvoiceStatus(statusData) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.specSheetId);
    const sheet = ss.getSheetByName('InvoiceStatuses');
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    
    const keyCol = headers.indexOf('status_key');
    let rowIndex = -1;
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][keyCol] === statusData.status_key) {
        rowIndex = i;
        break;
      }
    }
    
    if (rowIndex === -1) {
      const newRow = headers.map(h => statusData[h] ?? '');
      sheet.appendRow(newRow);
      Logger.log('✓ Invoice status created: ' + statusData.status_key);
    } else {
      headers.forEach((h, col) => {
        if (statusData[h] !== undefined) {
          sheet.getRange(rowIndex + 1, col + 1).setValue(statusData[h]);
        }
      });
      Logger.log('✓ Invoice status updated: ' + statusData.status_key);
    }
    
    return { ok: true };
    
  } catch (error) {
    Logger.log('saveInvoiceStatus error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

function deleteInvoiceStatus(statusKey) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.specSheetId);
    const sheet = ss.getSheetByName('InvoiceStatuses');
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    const keyCol = headers.indexOf('status_key');
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][keyCol] === statusKey) {
        sheet.deleteRow(i + 1);
        Logger.log('✓ Invoice status deleted: ' + statusKey);
        return { ok: true };
      }
    }
    
    return { ok: false, error: 'Status not found' };
    
  } catch (error) {
    Logger.log('deleteInvoiceStatus error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

// ============================================================================
// TASK BOARD - GET & UPDATE TASKS
// ============================================================================

/**
 * Get all tasks with invoice info
 */
function getAllTasks() {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    
    // Helper to sanitize dates
    function sanitize(val) {
      if (val instanceof Date) return val.toISOString();
      return val;
    }
    
    // Get tasks
    const tasksSheet = ss.getSheetByName('Tasks');
    let tasks = [];
    
    if (tasksSheet) {
      const data = tasksSheet.getDataRange().getValues();
      if (data.length > 1) {
        const headers = data[0];
        const taskIdCol = headers.indexOf('task_id');
        // Regex: valid task_id is YYMMDD-### format (e.g., 260106-001)
        const validTaskIdPattern = /^\d{6}-\d{3}$/;
        
        for (let i = 1; i < data.length; i++) {
          // Skip documentation/reference rows - only include real tasks
          const taskId = data[i][taskIdCol];
          if (!taskId || !validTaskIdPattern.test(taskId)) {
            continue;
          }
          
          const task = {};
          headers.forEach((h, col) => {
            task[h] = sanitize(data[i][col]);
          });
          tasks.push(task);
        }
      }
    }
    
    // Get invoices for reference
    const invoicesSheet = ss.getSheetByName('Invoices');
    let invoices = [];
    
    if (invoicesSheet) {
      const data = invoicesSheet.getDataRange().getValues();
      if (data.length > 1) {
        const headers = data[0];
        for (let i = 1; i < data.length; i++) {
          const inv = {};
          headers.forEach((h, col) => {
            inv[h] = sanitize(data[i][col]);
          });
          invoices.push(inv);
        }
      }
    }
    
    Logger.log('getAllTasks: Found ' + tasks.length + ' tasks, ' + invoices.length + ' invoices');
    
    return {
      ok: true,
      tasks: tasks,
      invoices: invoices
    };
    
  } catch (error) {
    Logger.log('getAllTasks error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Create a new task (from modal)
 */
function createTask(taskData) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const sheet = ss.getSheetByName('Tasks');
    
    if (!sheet) {
      return { ok: false, error: 'Tasks sheet not found' };
    }
    
    // Generate task ID
    const taskId = generateId('TASK', 'TASK_COUNTER');
    
    // Build row data
    const rowData = [
      taskId,                                    // task_id
      now(),                                     // created_at
      'MANUAL',                                  // type
      taskData.status || 'TO_DO',                // status
      taskData.title || '',                      // title
      taskData.description || '',                // description
      taskData.submission_id || '',              // submission_id
      taskData.quote_id || '',                   // quote_id
      taskData.invoice_id || '',                 // invoice_id
      taskData.assigned_to || '',                // assigned_to
      taskData.due_date || '',                   // due_date
      '',                                        // completed_at
      taskData.priority || 'NORMAL',             // priority
      false,                                     // auto_generated
      taskData.notes || ''                       // notes
    ];
    
    sheet.appendRow(rowData);
    Logger.log('✓ Task created: ' + taskId);
    
    return { ok: true, task_id: taskId };
    
  } catch (error) {
    Logger.log('createTask error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Save task updates (from modal)
 */
function saveTask(taskData) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const sheet = ss.getSheetByName('Tasks');
    
    if (!sheet) {
      return { ok: false, error: 'Tasks sheet not found' };
    }
    
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    const taskIdCol = headers.indexOf('task_id');
    
    // Find the row
    for (let i = 1; i < data.length; i++) {
      if (data[i][taskIdCol] === taskData.task_id) {
        // Update each field that exists in taskData
        headers.forEach((h, col) => {
          if (taskData[h] !== undefined && h !== 'task_id' && h !== 'created_at') {
            sheet.getRange(i + 1, col + 1).setValue(taskData[h]);
          }
        });
        
        Logger.log('✓ Task saved: ' + taskData.task_id);
        
        // Check automations if status changed
        if (taskData.status) {
          checkTaskAutomations(taskData.task_id);
        }
        
        return { ok: true };
      }
    }
    
    return { ok: false, error: 'Task not found' };
    
  } catch (error) {
    Logger.log('saveTask error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Delete a task
 */
function deleteTask(taskId) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const sheet = ss.getSheetByName('Tasks');
    
    if (!sheet) {
      return { ok: false, error: 'Tasks sheet not found' };
    }
    
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    const taskIdCol = headers.indexOf('task_id');
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][taskIdCol] === taskId) {
        sheet.deleteRow(i + 1);
        Logger.log('✓ Task deleted: ' + taskId);
        return { ok: true };
      }
    }
    
    return { ok: false, error: 'Task not found' };
    
  } catch (error) {
    Logger.log('deleteTask error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Update a task's status
 */
function updateTaskStatus(taskId, newStatus) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const sheet = ss.getSheetByName('Tasks');
    
    if (!sheet) {
      return { ok: false, error: 'Tasks sheet not found' };
    }
    
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    const taskIdCol = headers.indexOf('task_id');
    const statusCol = headers.indexOf('status');
    
    if (taskIdCol === -1 || statusCol === -1) {
      return { ok: false, error: 'Required columns not found' };
    }
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][taskIdCol] === taskId) {
        sheet.getRange(i + 1, statusCol + 1).setValue(newStatus);
        Logger.log('✓ Task ' + taskId + ' status updated to ' + newStatus);
        
        // Check automations
        checkTaskAutomations(taskId);
        
        return { ok: true };
      }
    }
    
    return { ok: false, error: 'Task not found' };
    
  } catch (error) {
    Logger.log('updateTaskStatus error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Generate tasks for an invoice from its category's workflow template
 */
function generateTasksForInvoice(invoiceId) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const specSs = SpreadsheetApp.openById(CONFIG.specSheetId);
    
    // Get the invoice from Documents sheet (unified doc model)
    const invoicesSheet = ss.getSheetByName('Documents');
    const invoicesData = invoicesSheet.getDataRange().getValues();
    const invoicesHeaders = invoicesData[0];
    const invIdCol = invoicesHeaders.indexOf('doc_id');
    const categoryCol = invoicesHeaders.indexOf('category');
    
    let invoice = null;
    for (let i = 1; i < invoicesData.length; i++) {
      if (invoicesData[i][invIdCol] === invoiceId) {
        invoice = {};
        invoicesHeaders.forEach((h, col) => {
          invoice[h] = invoicesData[i][col];
        });
        break;
      }
    }
    
    if (!invoice) {
      return { ok: false, error: 'Invoice not found' };
    }
    
    const categoryKey = invoice.category;
    if (!categoryKey) {
      return { ok: false, error: 'Invoice has no category set' };
    }
    
    // Find workflow template for this category
    const templatesSheet = specSs.getSheetByName('ProjectTemplates');
    const templatesData = templatesSheet.getDataRange().getValues();
    const templatesHeaders = templatesData[0];
    const templateKeyCol = templatesHeaders.indexOf('template_key');
    const templateCategoryCol = templatesHeaders.indexOf('category_key');
    const templateActiveCol = templatesHeaders.indexOf('active');
    
    let templateKey = null;
    for (let i = 1; i < templatesData.length; i++) {
      if (templatesData[i][templateCategoryCol] === categoryKey && templatesData[i][templateActiveCol] !== false) {
        templateKey = templatesData[i][templateKeyCol];
        break;
      }
    }
    
    if (!templateKey) {
      return { ok: false, error: 'No workflow template found for category: ' + categoryKey };
    }
    
    // Get template tasks
    const templateTasksSheet = specSs.getSheetByName('TemplateTasks');
    const templateTasksData = templateTasksSheet.getDataRange().getValues();
    const ttHeaders = templateTasksData[0];
    const ttTemplateKeyCol = ttHeaders.indexOf('template_key');
    const ttTaskKeyCol = ttHeaders.indexOf('task_key');
    const ttLabelCol = ttHeaders.indexOf('label');
    const ttPriorityCol = ttHeaders.indexOf('default_priority');
    const ttSortCol = ttHeaders.indexOf('sort_order');
    const ttActiveCol = ttHeaders.indexOf('active');
    
    const templateTasks = [];
    for (let i = 1; i < templateTasksData.length; i++) {
      if (templateTasksData[i][ttTemplateKeyCol] === templateKey && templateTasksData[i][ttActiveCol] !== false) {
        templateTasks.push({
          task_key: templateTasksData[i][ttTaskKeyCol],
          label: templateTasksData[i][ttLabelCol],
          priority: templateTasksData[i][ttPriorityCol],
          sort_order: templateTasksData[i][ttSortCol]
        });
      }
    }
    
    if (templateTasks.length === 0) {
      return { ok: false, error: 'No tasks in template: ' + templateKey };
    }
    
    // Sort by sort_order
    templateTasks.sort((a, b) => (a.sort_order || 0) - (b.sort_order || 0));
    
    // Check if tasks already exist for this invoice
    const tasksSheet = ss.getSheetByName('Tasks');
    const tasksData = tasksSheet.getDataRange().getValues();
    const tasksHeaders = tasksData[0];
    const taskInvoiceCol = tasksHeaders.indexOf('invoice_id');
    
    for (let i = 1; i < tasksData.length; i++) {
      if (tasksData[i][taskInvoiceCol] === invoiceId) {
        return { ok: false, error: 'Tasks already exist for this invoice. Delete them first to regenerate.' };
      }
    }
    
    // Create tasks
    const now = new Date().toISOString();
    const newTasks = templateTasks.map((tt, index) => {
      const taskId = 'TASK-' + invoiceId + '-' + (index + 1).toString().padStart(2, '0');
      return [
        taskId,                    // task_id
        now,                       // created_at
        'invoice',                 // type
        'TODO',                    // status
        tt.label,                  // title
        '',                        // description
        '',                        // submission_id
        '',                        // quote_id
        invoiceId,                 // invoice_id
        '',                        // assigned_to
        '',                        // due_date
        '',                        // completed_at
        tt.priority || 'MEDIUM',   // priority
        'TRUE',                    // auto_generated
        ''                         // notes
      ];
    });
    
    // Append tasks
    if (newTasks.length > 0) {
      tasksSheet.getRange(tasksSheet.getLastRow() + 1, 1, newTasks.length, newTasks[0].length).setValues(newTasks);
    }
    
    Logger.log('✓ Generated ' + newTasks.length + ' tasks for invoice ' + invoiceId);
    
    return { 
      ok: true, 
      tasksCreated: newTasks.length,
      templateUsed: templateKey
    };
    
  } catch (error) {
    Logger.log('generateTasksForInvoice error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Get tasks for a specific invoice
 */
function getTasksForInvoice(invoiceId) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const sheet = ss.getSheetByName('Tasks');
    
    if (!sheet) {
      return { ok: true, tasks: [] };
    }
    
    const data = sheet.getDataRange().getValues();
    if (data.length < 2) {
      return { ok: true, tasks: [] };
    }
    
    const headers = data[0];
    const invoiceCol = headers.indexOf('invoice_id');
    const tasks = [];
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][invoiceCol] === invoiceId) {
        const task = {};
        headers.forEach((h, col) => {
          task[h] = data[i][col];
        });
        tasks.push(task);
      }
    }
    
    // Sort by sort order if available, otherwise by task_id
    tasks.sort((a, b) => {
      const aNum = parseInt(a.task_id?.split('-').pop()) || 0;
      const bNum = parseInt(b.task_id?.split('-').pop()) || 0;
      return aNum - bNum;
    });
    
    return { ok: true, tasks: tasks };
    
  } catch (error) {
    Logger.log('getTasksForInvoice error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Toggle task status between TODO and DONE
 */
function toggleTaskStatus(taskId) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const specSs = SpreadsheetApp.openById(CONFIG.specSheetId);
    const sheet = ss.getSheetByName('Tasks');
    
    if (!sheet) {
      return { ok: false, error: 'Tasks sheet not found' };
    }
    
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    const taskIdCol = headers.indexOf('task_id');
    const statusCol = headers.indexOf('status');
    
    // Get status config to know what's "complete"
    const statusesSheet = specSs.getSheetByName('TaskStatuses');
    const statusesData = statusesSheet.getDataRange().getValues();
    const statusHeaders = statusesData[0];
    const statusKeyCol = statusHeaders.indexOf('status_key');
    const isCompleteCol = statusHeaders.indexOf('is_complete');
    
    const completeStatuses = [];
    let doneStatus = 'DONE';
    let todoStatus = 'TODO';
    
    for (let i = 1; i < statusesData.length; i++) {
      if (statusesData[i][isCompleteCol] === true) {
        completeStatuses.push(statusesData[i][statusKeyCol]);
        if (!doneStatus || statusesData[i][statusKeyCol] === 'DONE') {
          doneStatus = statusesData[i][statusKeyCol];
        }
      } else if (statusesData[i][statusKeyCol] === 'TODO') {
        todoStatus = statusesData[i][statusKeyCol];
      }
    }
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][taskIdCol] === taskId) {
        const currentStatus = data[i][statusCol];
        const isCurrentlyComplete = completeStatuses.includes(currentStatus);
        const newStatus = isCurrentlyComplete ? todoStatus : doneStatus;
        
        sheet.getRange(i + 1, statusCol + 1).setValue(newStatus);
        Logger.log('✓ Task ' + taskId + ' toggled: ' + currentStatus + ' → ' + newStatus);
        
        // Check automations
        checkTaskAutomations(taskId);
        
        return { ok: true, newStatus: newStatus };
      }
    }
    
    return { ok: false, error: 'Task not found' };
    
  } catch (error) {
    Logger.log('toggleTaskStatus error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Check and run task automations
 */
function checkTaskAutomations(taskId) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const specSs = SpreadsheetApp.openById(CONFIG.specSheetId);
    
    // Get the task to find its invoice
    const tasksSheet = ss.getSheetByName('Tasks');
    const tasksData = tasksSheet.getDataRange().getValues();
    const tasksHeaders = tasksData[0];
    const taskIdCol = tasksHeaders.indexOf('task_id');
    const invoiceIdCol = tasksHeaders.indexOf('invoice_id');
    const statusCol = tasksHeaders.indexOf('status');
    
    let invoiceId = null;
    for (let i = 1; i < tasksData.length; i++) {
      if (tasksData[i][taskIdCol] === taskId) {
        invoiceId = tasksData[i][invoiceIdCol];
        break;
      }
    }
    
    if (!invoiceId) return;
    
    // Get all tasks for this invoice
    const invoiceTasks = [];
    for (let i = 1; i < tasksData.length; i++) {
      if (tasksData[i][invoiceIdCol] === invoiceId) {
        invoiceTasks.push({
          task_id: tasksData[i][taskIdCol],
          status: tasksData[i][statusCol]
        });
      }
    }
    
    // Get task statuses to check completion
    const statusesSheet = specSs.getSheetByName('TaskStatuses');
    const statusesData = statusesSheet.getDataRange().getValues();
    const statusesHeaders = statusesData[0];
    const statusKeyCol = statusesHeaders.indexOf('status_key');
    const isCompleteCol = statusesHeaders.indexOf('is_complete');
    
    const completeStatuses = [];
    for (let i = 1; i < statusesData.length; i++) {
      if (statusesData[i][isCompleteCol] === true) {
        completeStatuses.push(statusesData[i][statusKeyCol]);
      }
    }
    
    // Check if all tasks are complete
    const allComplete = invoiceTasks.every(t => completeStatuses.includes(t.status));
    const anyInProgress = invoiceTasks.some(t => t.status === 'IN_PROGRESS');
    
    // Get automations
    const autoSheet = specSs.getSheetByName('Automations');
    const autoData = autoSheet.getDataRange().getValues();
    const autoHeaders = autoData[0];
    
    for (let i = 1; i < autoData.length; i++) {
      const automation = {};
      autoHeaders.forEach((h, col) => {
        automation[h] = autoData[i][col];
      });
      
      if (!automation.active) continue;
      
      // Check trigger conditions
      let shouldTrigger = false;
      
      if (automation.trigger_type === 'all_tasks_complete' && allComplete) {
        shouldTrigger = true;
      } else if (automation.trigger_type === 'any_task_in_progress' && anyInProgress) {
        shouldTrigger = true;
      }
      
      if (shouldTrigger && automation.target_field === 'invoice_status') {
        // Update invoice status
        const invoicesSheet = ss.getSheetByName('Invoices');
        const invoicesData = invoicesSheet.getDataRange().getValues();
        const invoicesHeaders = invoicesData[0];
        const invIdCol = invoicesHeaders.indexOf('invoice_id');
        const invStatusCol = invoicesHeaders.indexOf('status');
        
        for (let j = 1; j < invoicesData.length; j++) {
          if (invoicesData[j][invIdCol] === invoiceId) {
            invoicesSheet.getRange(j + 1, invStatusCol + 1).setValue(automation.new_value);
            Logger.log('✓ Automation triggered: Invoice ' + invoiceId + ' status → ' + automation.new_value);
            break;
          }
        }
      }
    }
    
  } catch (error) {
    Logger.log('checkTaskAutomations error: ' + error.toString());
  }
}

function testQuoteBuilderConfig() {
  const result = getQuoteBuilderConfig();
  Logger.log('Result OK: ' + result.ok);
  Logger.log('Categories count: ' + (result.categories ? result.categories.length : 0));
  if (result.categories && result.categories.length > 0) {
    Logger.log('First category: ' + JSON.stringify(result.categories[0]));
  }
}


// ============================================================================
// CUSTOMER DATABASE
// ============================================================================

/**
 * Get all customers with optional search/filter
 */
function getCustomers(options) {
  try {
    options = options || {};
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const sheet = ss.getSheetByName(CONFIG.sheets.customers);
    
    if (!sheet) {
      return { ok: false, error: 'Customers sheet not found' };
    }
    
    const data = sheet.getDataRange().getValues();
    if (data.length < 2) {
      return { ok: true, customers: [] };
    }
    
    const headers = data[0];
    let customers = [];
    
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      if (!row[0]) continue; // Skip empty rows
      
      const customer = {};
      headers.forEach((h, col) => {
        let val = row[col];
        if (val instanceof Date) val = val.toISOString();
        customer[h] = val;
      });
      
      // Skip archived unless requested
      if (customer.archived === true && !options.includeArchived) continue;
      
      customers.push(customer);
    }
    
    // Search filter
    if (options.search) {
      const searchLower = options.search.toLowerCase();
      customers = customers.filter(c => {
        return (c.display_name && String(c.display_name).toLowerCase().includes(searchLower)) ||
               (c.email && String(c.email).toLowerCase().includes(searchLower)) ||
               (c.phone && String(c.phone).includes(searchLower)) ||
               (c.company && String(c.company).toLowerCase().includes(searchLower)) ||
               (c.first_name && String(c.first_name).toLowerCase().includes(searchLower)) ||
               (c.last_name && String(c.last_name).toLowerCase().includes(searchLower));
      });
    }
    
    // Sort by lifetime_value desc by default
    customers.sort((a, b) => (b.lifetime_value || 0) - (a.lifetime_value || 0));
    
    // Limit results
    if (options.limit) {
      customers = customers.slice(0, options.limit);
    }
    
    return { ok: true, customers: customers, total: customers.length };
    
  } catch (error) {
    Logger.log('getCustomers error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Get a single customer with their history
 */
function getCustomerWithHistory(customerId) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    
    // Get customer
    const custSheet = ss.getSheetByName(CONFIG.sheets.customers);
    const custData = custSheet.getDataRange().getValues();
    const custHeaders = custData[0];
    
    let customer = null;
    for (let i = 1; i < custData.length; i++) {
      if (custData[i][0] === customerId) {
        customer = {};
        custHeaders.forEach((h, col) => {
          let val = custData[i][col];
          if (val instanceof Date) val = val.toISOString();
          customer[h] = val;
        });
        break;
      }
    }
    
    if (!customer) {
      return { ok: false, error: 'Customer not found' };
    }
    
    // Find related records by email or phone
    const email = customer.email ? customer.email.toLowerCase() : '';
    const phone = customer.phone || '';
    
    // Get submissions
    const submissions = [];
    const subSheet = ss.getSheetByName(CONFIG.sheets.submissions);
    if (subSheet) {
      const subData = subSheet.getDataRange().getValues();
      const subHeaders = subData[0];
      const emailCol = subHeaders.indexOf('customer_email');
      const phoneCol = subHeaders.indexOf('customer_phone');
      
      for (let i = 1; i < subData.length; i++) {
        const rowEmail = (subData[i][emailCol] || '').toLowerCase();
        const rowPhone = (subData[i][phoneCol] || '').toString().replace(/\D/g, '').slice(-10);
        
        if ((email && rowEmail === email) || (phone && rowPhone === phone)) {
          const sub = {};
          subHeaders.forEach((h, col) => {
            let val = subData[i][col];
            if (val instanceof Date) val = val.toISOString();
            sub[h] = val;
          });
          submissions.push(sub);
        }
      }
    }
    
    // Get quotes
    const quotes = [];
    const quoteSheet = ss.getSheetByName(CONFIG.sheets.quotes);
    if (quoteSheet) {
      const quoteData = quoteSheet.getDataRange().getValues();
      const quoteHeaders = quoteData[0];
      const emailCol = quoteHeaders.indexOf('customer_email');
      const phoneCol = quoteHeaders.indexOf('customer_phone');
      
      for (let i = 1; i < quoteData.length; i++) {
        const rowEmail = (quoteData[i][emailCol] || '').toLowerCase();
        const rowPhone = (quoteData[i][phoneCol] || '').toString().replace(/\D/g, '').slice(-10);
        
        if ((email && rowEmail === email) || (phone && rowPhone === phone)) {
          const quote = {};
          quoteHeaders.forEach((h, col) => {
            let val = quoteData[i][col];
            if (val instanceof Date) val = val.toISOString();
            quote[h] = val;
          });
          quotes.push(quote);
        }
      }
    }
    
    // Get invoices
    const invoices = [];
    const invSheet = ss.getSheetByName(CONFIG.sheets.invoices);
    if (invSheet) {
      const invData = invSheet.getDataRange().getValues();
      const invHeaders = invData[0];
      const emailCol = invHeaders.indexOf('customer_email');
      const phoneCol = invHeaders.indexOf('customer_phone');
      
      for (let i = 1; i < invData.length; i++) {
        const rowEmail = (invData[i][emailCol] || '').toLowerCase();
        const rowPhone = (invData[i][phoneCol] || '').toString().replace(/\D/g, '').slice(-10);
        
        if ((email && rowEmail === email) || (phone && rowPhone === phone)) {
          const inv = {};
          invHeaders.forEach((h, col) => {
            let val = invData[i][col];
            if (val instanceof Date) val = val.toISOString();
            inv[h] = val;
          });
          invoices.push(inv);
        }
      }
    }
    
    return {
      ok: true,
      customer: customer,
      submissions: submissions,
      quotes: quotes,
      invoices: invoices
    };
    
  } catch (error) {
    Logger.log('getCustomerWithHistory error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Update a customer
 */
function updateCustomer(customerId, updates) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const sheet = ss.getSheetByName(CONFIG.sheets.customers);
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][0] === customerId) {
        // Update each field
        Object.keys(updates).forEach(field => {
          const col = headers.indexOf(field);
          if (col > 0) { // Don't update customer_id (col 0)
            sheet.getRange(i + 1, col + 1).setValue(updates[field]);
          }
        });
        
        Logger.log('✓ Customer updated: ' + customerId);
        return { ok: true };
      }
    }
    
    return { ok: false, error: 'Customer not found' };
    
  } catch (error) {
    Logger.log('updateCustomer error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Add an attachment to a customer's project files
 */
function addCustomerAttachment(customerId, attachment) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const sheet = ss.getSheetByName(CONFIG.sheets.customers);
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    
    const idCol = headers.indexOf('customer_id');
    const filesCol = headers.indexOf('project_files_json');
    
    if (filesCol === -1) {
      return { ok: false, error: 'project_files_json column not found' };
    }
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][idCol] === customerId) {
        let files = [];
        try {
          if (data[i][filesCol]) {
            files = JSON.parse(data[i][filesCol]);
          }
        } catch (e) {
          files = [];
        }
        
        files.push(attachment);
        sheet.getRange(i + 1, filesCol + 1).setValue(JSON.stringify(files));
        
        return { ok: true };
      }
    }
    
    return { ok: false, error: 'Customer not found' };
    
  } catch (error) {
    Logger.log('addCustomerAttachment error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Delete an attachment from a customer's project files
 */
function deleteCustomerAttachment(customerId, fileIndex) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const sheet = ss.getSheetByName(CONFIG.sheets.customers);
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    
    const idCol = headers.indexOf('customer_id');
    const filesCol = headers.indexOf('project_files_json');
    
    if (filesCol === -1) {
      return { ok: false, error: 'project_files_json column not found' };
    }
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][idCol] === customerId) {
        let files = [];
        try {
          if (data[i][filesCol]) {
            files = JSON.parse(data[i][filesCol]);
          }
        } catch (e) {
          files = [];
        }
        
        if (fileIndex >= 0 && fileIndex < files.length) {
          files.splice(fileIndex, 1);
          sheet.getRange(i + 1, filesCol + 1).setValue(files.length > 0 ? JSON.stringify(files) : '');
        }
        
        return { ok: true };
      }
    }
    
    return { ok: false, error: 'Customer not found' };
    
  } catch (error) {
    Logger.log('deleteCustomerAttachment error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Create a new customer
 */
function createCustomer(customerData) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const sheet = ss.getSheetByName(CONFIG.sheets.customers);
    
    // Generate customer ID
    const customerId = generateId('CUS', 'CUSTOMER_COUNTER');
    
    // Build display name
    let displayName = customerData.company || '';
    if (!displayName && (customerData.first_name || customerData.last_name)) {
      displayName = ((customerData.first_name || '') + ' ' + (customerData.last_name || '')).trim();
    }
    if (!displayName) {
      displayName = customerData.email || 'Unknown';
    }
    
    const rowData = [
      customerId,
      new Date().toISOString(),
      customerData.first_name || '',
      customerData.last_name || '',
      displayName,
      (customerData.email || '').toLowerCase().trim(),
      (customerData.phone || '').replace(/\D/g, '').slice(-10),
      customerData.company || '',
      customerData.address || '',
      customerData.city || '',
      customerData.state || '',
      customerData.zip || '',
      customerData.tags || '',
      customerData.notes || '',
      customerData.drive_folder_url || '',
      0, // lifetime_value starts at 0
      'Manual',
      false // archived
    ];
    
    sheet.appendRow(rowData);
    Logger.log('✓ Customer created: ' + customerId);
    
    return { ok: true, customer_id: customerId };
    
  } catch (error) {
    Logger.log('createCustomer error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Find or create customer by email/phone (for auto-capture from submissions)
 */
function findOrCreateCustomer(customerData) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const sheet = ss.getSheetByName(CONFIG.sheets.customers);
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    
    const emailCol = headers.indexOf('email');
    const phoneCol = headers.indexOf('phone');
    
    const searchEmail = (customerData.email || '').toLowerCase().trim();
    const searchPhone = (customerData.phone || '').replace(/\D/g, '').slice(-10);
    
    // Search for existing customer
    for (let i = 1; i < data.length; i++) {
      const rowEmail = (data[i][emailCol] || '').toLowerCase();
      const rowPhone = (data[i][phoneCol] || '').toString();
      
      if ((searchEmail && rowEmail === searchEmail) || (searchPhone && rowPhone === searchPhone)) {
        // Found existing customer
        return { ok: true, customer_id: data[i][0], existing: true };
      }
    }
    
    // No match - create new customer
    const result = createCustomer(customerData);
    if (result.ok) {
      return { ok: true, customer_id: result.customer_id, existing: false };
    }
    return result;
    
  } catch (error) {
    Logger.log('findOrCreateCustomer error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}


// ============================================================================
// LINE ITEM FILE ATTACHMENTS
// ============================================================================

/**
 * Upload a file attachment for a line item
 * @param {string} lineItemId - The line item ID (e.g., QLI-260115-001 or ILI-260115-001)
 * @param {string} itemType - 'quote' or 'invoice'
 * @param {Object} fileData - { name, mimeType, base64Data }
 * @param {string} driveFolderId - Optional Drive folder ID to store in
 */
function uploadLineItemAttachment(lineItemId, itemType, fileData, driveFolderId) {
  try {
    Logger.log('=== Uploading Line Item Attachment ===');
    Logger.log('Line Item: ' + lineItemId + ', Type: ' + itemType);
    Logger.log('File: ' + fileData.name + ' (' + fileData.mimeType + ')');
    
    // Decode base64 data
    const decodedData = Utilities.base64Decode(fileData.base64Data);
    const blob = Utilities.newBlob(decodedData, fileData.mimeType, fileData.name);
    
    // Determine folder - use provided folder or create/use default
    let folder;
    if (driveFolderId) {
      try {
        folder = DriveApp.getFolderById(driveFolderId);
      } catch (e) {
        Logger.log('Could not access folder ' + driveFolderId + ', using default');
        folder = getOrCreateAttachmentsFolder(itemType, lineItemId);
      }
    } else {
      folder = getOrCreateAttachmentsFolder(itemType, lineItemId);
    }
    
    // Upload file
    const file = folder.createFile(blob);
    file.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW);
    
    const fileId = file.getId();
    const fileName = file.getName();
    const fileUrl = file.getUrl();
    const downloadUrl = 'https://drive.google.com/uc?export=download&id=' + fileId;
    const viewUrl = 'https://drive.google.com/uc?export=view&id=' + fileId;
    
    // For images, get thumbnail URL
    let thumbnailUrl = '';
    if (fileData.mimeType.startsWith('image/')) {
      thumbnailUrl = 'https://drive.google.com/thumbnail?id=' + fileId + '&sz=w200';
    }
    
    // Create attachment record
    const attachment = {
      file_id: fileId,
      file_name: fileName,
      mime_type: fileData.mimeType,
      file_url: fileUrl,
      view_url: viewUrl,
      download_url: downloadUrl,
      thumbnail_url: thumbnailUrl,
      uploaded_at: new Date().toISOString()
    };
    
    // Update line item's attachments JSON
    const updateResult = addAttachmentToLineItem(lineItemId, itemType, attachment);
    if (!updateResult.ok) {
      return updateResult;
    }
    
    Logger.log('✓ File uploaded: ' + fileId);
    return { ok: true, attachment: attachment };
    
  } catch (error) {
    Logger.log('uploadLineItemAttachment error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Handle file upload from POST request (bypasses google.script.run size limits)
 */
function uploadFileFromPost(data) {
  try {
    const { lineItemId, itemType, fileName, mimeType, base64Data } = data;
    
    Logger.log('=== Upload File From POST ===');
    Logger.log('Line Item: ' + lineItemId + ', Type: ' + itemType);
    Logger.log('File: ' + fileName + ' (' + mimeType + ')');
    Logger.log('Data length: ' + (base64Data ? base64Data.length : 0));
    
    // Decode base64 and create blob
    const decodedData = Utilities.base64Decode(base64Data);
    const blob = Utilities.newBlob(decodedData, mimeType, fileName);
    
    // Get or create folder
    const folder = getOrCreateAttachmentsFolder(itemType, lineItemId);
    
    // Upload file
    const file = folder.createFile(blob);
    file.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW);
    
    const fileId = file.getId();
    const fileUrl = file.getUrl();
    
    // Build attachment object
    const attachment = {
      file_id: fileId,
      file_name: fileName,
      mime_type: mimeType,
      file_url: fileUrl,
      view_url: 'https://drive.google.com/file/d/' + fileId + '/view',
      download_url: 'https://drive.google.com/uc?export=download&id=' + fileId,
      thumbnail_url: mimeType.startsWith('image/') ? 'https://drive.google.com/thumbnail?id=' + fileId + '&sz=w200' : '',
      uploaded_at: new Date().toISOString()
    };
    
    // Save to line item
    const saveResult = addAttachmentToLineItem(lineItemId, itemType, attachment);
    if (!saveResult.ok) {
      return saveResult;
    }
    
    Logger.log('✓ File uploaded: ' + fileId);
    return { ok: true, attachment: attachment };
    
  } catch (error) {
    Logger.log('uploadFileFromPost error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Get or create the attachments folder for a line item
 */
function getOrCreateAttachmentsFolder(itemType, lineItemId) {
  // Get root FWG folder
  const rootFolderName = 'FWG_Attachments';
  let rootFolder;
  
  const rootFolders = DriveApp.getFoldersByName(rootFolderName);
  if (rootFolders.hasNext()) {
    rootFolder = rootFolders.next();
  } else {
    rootFolder = DriveApp.createFolder(rootFolderName);
  }
  
  // Get or create subfolder for quotes/invoices
  const subFolderName = itemType === 'quote' ? 'Quotes' : 'Invoices';
  let subFolder;
  
  const subFolders = rootFolder.getFoldersByName(subFolderName);
  if (subFolders.hasNext()) {
    subFolder = subFolders.next();
  } else {
    subFolder = rootFolder.createFolder(subFolderName);
  }
  
  // Get or create folder for this specific item
  // Extract parent ID (e.g., Q-260115-001 from QLI-260115-001-01)
  const parentId = lineItemId.replace(/^[QI]LI-/, (itemType === 'quote' ? 'Q-' : 'INV-')).replace(/-\d+$/, '');
  let itemFolder;
  
  const itemFolders = subFolder.getFoldersByName(parentId);
  if (itemFolders.hasNext()) {
    itemFolder = itemFolders.next();
  } else {
    itemFolder = subFolder.createFolder(parentId);
  }
  
  return itemFolder;
}

/**
 * Add attachment reference to line item's JSON field
 */
function addAttachmentToLineItem(lineItemId, itemType, attachment) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const sheetName = itemType === 'quote' ? 'QuoteLineItems' : 'InvoiceLineItems';
    const sheet = ss.getSheetByName(sheetName);
    
    if (!sheet) {
      return { ok: false, error: sheetName + ' sheet not found' };
    }
    
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    const idCol = headers.indexOf('line_id');
    let attachCol = headers.indexOf('attachments_json');
    
    // If attachments_json column doesn't exist, add it
    if (attachCol === -1) {
      sheet.getRange(1, headers.length + 1).setValue('attachments_json');
      attachCol = headers.length;
    }
    
    // Find the line item row
    for (let i = 1; i < data.length; i++) {
      if (data[i][idCol] === lineItemId) {
        // Get existing attachments
        let attachments = [];
        const existingJson = data[i][attachCol];
        if (existingJson) {
          try {
            attachments = JSON.parse(existingJson);
          } catch (e) {
            attachments = [];
          }
        }
        
        // Add new attachment
        attachments.push(attachment);
        
        // Save back
        sheet.getRange(i + 1, attachCol + 1).setValue(JSON.stringify(attachments));
        return { ok: true };
      }
    }
    
    return { ok: false, error: 'Line item not found: ' + lineItemId };
    
  } catch (error) {
    Logger.log('addAttachmentToLineItem error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Get attachments for a line item
 */
function getLineItemAttachments(lineItemId, itemType) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const sheetName = itemType === 'quote' ? 'QuoteLineItems' : 'InvoiceLineItems';
    const sheet = ss.getSheetByName(sheetName);
    
    if (!sheet) {
      return { ok: true, attachments: [] };
    }
    
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    const idCol = headers.indexOf('line_id');
    const attachCol = headers.indexOf('attachments_json');
    
    if (attachCol === -1) {
      return { ok: true, attachments: [] };
    }
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][idCol] === lineItemId) {
        const json = data[i][attachCol];
        if (json) {
          try {
            return { ok: true, attachments: JSON.parse(json) };
          } catch (e) {
            return { ok: true, attachments: [] };
          }
        }
        return { ok: true, attachments: [] };
      }
    }
    
    return { ok: true, attachments: [] };
    
  } catch (error) {
    Logger.log('getLineItemAttachments error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Delete an attachment from a line item
 */
function deleteLineItemAttachment(lineItemId, itemType, fileId) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const sheetName = itemType === 'quote' ? 'QuoteLineItems' : 'InvoiceLineItems';
    const sheet = ss.getSheetByName(sheetName);
    
    if (!sheet) {
      return { ok: false, error: sheetName + ' sheet not found' };
    }
    
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    const idCol = headers.indexOf('line_id');
    const attachCol = headers.indexOf('attachments_json');
    
    if (attachCol === -1) {
      return { ok: false, error: 'No attachments column' };
    }
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][idCol] === lineItemId) {
        let attachments = [];
        const existingJson = data[i][attachCol];
        if (existingJson) {
          try {
            attachments = JSON.parse(existingJson);
          } catch (e) {
            attachments = [];
          }
        }
        
        // Remove the attachment
        attachments = attachments.filter(a => a.file_id !== fileId);
        
        // Save back
        sheet.getRange(i + 1, attachCol + 1).setValue(JSON.stringify(attachments));
        
        // Also delete from Drive
        try {
          DriveApp.getFileById(fileId).setTrashed(true);
        } catch (driveError) {
          Logger.log('Could not delete Drive file: ' + driveError.toString());
        }
        
        return { ok: true };
      }
    }
    
    return { ok: false, error: 'Line item not found' };
    
  } catch (error) {
    Logger.log('deleteLineItemAttachment error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

function TEST_customersSheet() {
  const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
  Logger.log('Spreadsheet name: ' + ss.getName());
  
  const sheets = ss.getSheets();
  Logger.log('All sheets:');
  sheets.forEach(s => Logger.log('  - ' + s.getName()));
  
  const custSheet = ss.getSheetByName('Customers');
  Logger.log('Customers sheet found: ' + (custSheet ? 'YES' : 'NO'));
  
  if (custSheet) {
    Logger.log('Rows: ' + custSheet.getLastRow());
  }
}

/**
 * Get or create a folder for line item attachments
 * Returns the folder ID for the Picker to upload to
 */
function getOrCreateAttachmentFolder(lineItemId, itemType) {
  try {
    const folder = getOrCreateAttachmentsFolder(itemType, lineItemId);
    return { ok: true, folderId: folder.getId() };
  } catch (error) {
    Logger.log('getOrCreateAttachmentFolder error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Get the web app URL for customer-facing links
 */
function getWebAppUrl() {
  return 'https://script.google.com/macros/s/AKfycbyro9xpTQcfUKdH1522diqCYqjzMeQI5UBCOu36GBsztyR1OGqQZBdLLL855lAx1Ltx/exec';
}

function testGetCustomers() {
  const result = getCustomers({ limit: 5 });
  Logger.log('Result: ' + JSON.stringify(result));
  return result;
}

// ============================================================================
// PRODUCTION FLOW - BACKEND FUNCTIONS
// ============================================================================

/**
 * Get all tasks in production (linked to invoices with status Paid or Partial)
 * Groups by invoice for the Production Flow board view
 */
function getProductionQueue() {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const specSs = SpreadsheetApp.openById(CONFIG.specSheetId);
    
    // Get all tasks linked to invoices
    const tasksSheet = ss.getSheetByName('Tasks');
    if (!tasksSheet) {
      return { ok: true, queue: [], categories: [] };
    }
    
    const tasksData = tasksSheet.getDataRange().getValues();
    if (tasksData.length < 2) {
      return { ok: true, queue: [], categories: [] };
    }
    
    const taskHeaders = tasksData[0];
    const invoiceIdCol = taskHeaders.indexOf('invoice_id');
    
    // Collect all invoice IDs that have tasks
    const invoiceIdsWithTasks = new Set();
    for (let i = 1; i < tasksData.length; i++) {
      const invoiceId = tasksData[i][invoiceIdCol];
      if (invoiceId) {
        invoiceIdsWithTasks.add(String(invoiceId));
      }
    }
    
    if (invoiceIdsWithTasks.size === 0) {
      return { ok: true, queue: [], categories: [] };
    }
    
    // Get Documents sheet
    const docsSheet = ss.getSheetByName('Documents');
    const docsData = docsSheet.getDataRange().getValues();
    const docHeaders = docsData[0];
    const docIdCol = docHeaders.indexOf('doc_id');
    const docTypeCol = docHeaders.indexOf('doc_type');
    const docStatusCol = docHeaders.indexOf('status');
    const categoryCol = docHeaders.indexOf('category');
    const paidAtCol = docHeaders.indexOf('paid_at');
    
    // Build invoice map - only include Paid or Partial invoices
    const invoiceMap = {};
    const categoriesSet = new Set();
    
    for (let i = 1; i < docsData.length; i++) {
      const docId = String(docsData[i][docIdCol]);
      const docType = String(docsData[i][docTypeCol]).toLowerCase();
      const docStatus = String(docsData[i][docStatusCol]).toLowerCase();
      
      if (docType === 'invoice' && (docStatus === 'paid' || docStatus === 'partial') && invoiceIdsWithTasks.has(docId)) {
        const doc = {};
        docHeaders.forEach((h, col) => { doc[h] = docsData[i][col]; });
        invoiceMap[docId] = doc;
        
        if (doc.category) {
          categoriesSet.add(doc.category);
        }
      }
    }
    
    // Build queue array (one job per invoice)
    const queue = [];
    
    for (const invoiceId of Object.keys(invoiceMap)) {
      const invoice = invoiceMap[invoiceId];
      
      // Get all tasks for this invoice
      const invoiceTasks = [];
      for (let i = 1; i < tasksData.length; i++) {
        if (String(tasksData[i][invoiceIdCol]) === invoiceId) {
          const task = {};
          taskHeaders.forEach((h, col) => { task[h] = tasksData[i][col]; });
          invoiceTasks.push(task);
        }
      }
      
      // Sort tasks by task_id order
      invoiceTasks.sort((a, b) => {
        const aNum = parseInt(a.task_id?.split('-').pop()) || 0;
        const bNum = parseInt(b.task_id?.split('-').pop()) || 0;
        return aNum - bNum;
      });
      
      // Group tasks by category (use invoice category as the group)
      const categoryKey = invoice.category || 'GENERAL';
      const taskGroup = {
        category: categoryKey,
        category_label: categoryKey.replace(/_/g, ' '),
        tasks: invoiceTasks.map(t => ({
          task_id: t.task_id,
          task_name: t.title,
          status: t.status,
          completed_at: t.completed_at,
          completed_by: t.assigned_to,
          has_automation: t.auto_generated === 'TRUE' || t.auto_generated === true
        }))
      };
      
      // Format paid_at date
      let paidAt = invoice.paid_at;
      if (paidAt instanceof Date) {
        paidAt = paidAt.toISOString();
      }
      
      queue.push({
        invoice_id: invoiceId,
        customer_name: invoice.customer_name || '',
        company_name: invoice.company_name || '',
        vehicle_description: invoice.vehicle_description || '',
        project_description: invoice.project_description || '',
        total: invoice.total || 0,
        status: invoice.status || '',
        paid_at: paidAt || '',
        task_groups: [taskGroup]
      });
    }
    
    // Sort queue by paid_at (most recent first)
    queue.sort((a, b) => {
      const aDate = a.paid_at ? new Date(a.paid_at) : new Date(0);
      const bDate = b.paid_at ? new Date(b.paid_at) : new Date(0);
      return bDate - aDate;
    });
    
    return {
      ok: true,
      queue: queue,
      categories: Array.from(categoriesSet)
    };
    
  } catch (error) {
    Logger.log('getProductionQueue error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Update a production task (status, notes, assigned_to, etc.)
 */
function updateProductionTask(taskId, updates) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const sheet = ss.getSheetByName('Tasks');
    
    if (!sheet) {
      return { ok: false, error: 'Tasks sheet not found' };
    }
    
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    const taskIdCol = headers.indexOf('task_id');
    
    if (taskIdCol === -1) {
      return { ok: false, error: 'task_id column not found' };
    }
    
    // Find the task row
    for (let i = 1; i < data.length; i++) {
      if (data[i][taskIdCol] === taskId) {
        // Update each field that's in the updates object
        Object.keys(updates).forEach(key => {
          const col = headers.indexOf(key);
          if (col !== -1 && key !== 'task_id' && key !== 'created_at') {
            let value = updates[key];
            
            // Handle completed_at timestamp
            if (key === 'status' && (value === 'DONE' || value === 'CANCELLED')) {
              const completedCol = headers.indexOf('completed_at');
              if (completedCol !== -1) {
                sheet.getRange(i + 1, completedCol + 1).setValue(new Date().toISOString());
              }
            } else if (key === 'status' && value !== 'DONE' && value !== 'CANCELLED') {
              // Clear completed_at if reverting from done
              const completedCol = headers.indexOf('completed_at');
              if (completedCol !== -1) {
                sheet.getRange(i + 1, completedCol + 1).setValue('');
              }
            }
            
            sheet.getRange(i + 1, col + 1).setValue(value);
          }
        });
        
        Logger.log('Task updated: ' + taskId + ' -> ' + JSON.stringify(updates));
        
        // Check and run automations if task was marked DONE
        if (updates.status === 'DONE') {
          const invoiceId = data[i][headers.indexOf('invoice_id')];
          if (invoiceId) {
            const autoResult = checkAndRunAutomations(taskId, invoiceId, 'DONE');
            Logger.log('Automation check result: ' + JSON.stringify(autoResult));
            return { 
              ok: true, 
              automations: autoResult.automations_run || [],
              all_complete: autoResult.all_complete || false,
              customer_name: autoResult.customer_name || '',
              invoice_id: invoiceId
            };
          }
        }
        
        return { ok: true };
      }
    }
    
    return { ok: false, error: 'Task not found: ' + taskId };
    
  } catch (error) {
    Logger.log('updateProductionTask error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Check and run automations after a task status change
 * Called by updateProductionTask when a task is marked DONE
 * Returns info about whether all tasks are complete (for frontend to show archive modal)
 */
function checkAndRunAutomations(taskId, invoiceId, newStatus) {
  try {
    if (newStatus !== 'DONE') {
      return { ok: true, automations_run: [], all_complete: false };
    }
    
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const specSs = SpreadsheetApp.openById(CONFIG.specSheetId);
    const automationsRun = [];
    
    // Get all tasks for this invoice
    const tasksSheet = ss.getSheetByName('Tasks');
    const tasksData = tasksSheet.getDataRange().getValues();
    const taskHeaders = tasksData[0];
    const taskIdCol = taskHeaders.indexOf('task_id');
    const invoiceIdCol = taskHeaders.indexOf('invoice_id');
    
    let taskKey = '';
    let allTasksForInvoice = [];
    
    for (let i = 1; i < tasksData.length; i++) {
      if (String(tasksData[i][invoiceIdCol]) === String(invoiceId)) {
        const task = {};
        taskHeaders.forEach((h, col) => { task[h] = tasksData[i][col]; });
        allTasksForInvoice.push(task);
        
        if (tasksData[i][taskIdCol] === taskId) {
          taskKey = task.title || '';
        }
      }
    }
    
    // Check if ALL tasks are now complete
    const allComplete = allTasksForInvoice.every(t => 
      t.status === 'DONE' || t.status === 'CANCELLED'
    );
    
    // Get invoice details for SMS
    const docsSheet = ss.getSheetByName('Documents');
    const docsData = docsSheet.getDataRange().getValues();
    const docHeaders = docsData[0];
    const docIdCol = docHeaders.indexOf('doc_id');
    let invoice = null;
    
    for (let i = 1; i < docsData.length; i++) {
      if (String(docsData[i][docIdCol]) === String(invoiceId)) {
        invoice = {};
        docHeaders.forEach((h, col) => { invoice[h] = docsData[i][col]; });
        break;
      }
    }
    
    // Load automations from spec sheet
    const autoSheet = specSs.getSheetByName('Automations');
    if (autoSheet) {
      const autoData = autoSheet.getDataRange().getValues();
      const autoHeaders = autoData[0];
      
      for (let i = 1; i < autoData.length; i++) {
        if (!autoData[i][0]) continue;
        
        const auto = {};
        autoHeaders.forEach((h, col) => { auto[h] = autoData[i][col]; });
        
        if (auto.active !== true && auto.active !== 'TRUE') continue;
        
        let shouldRun = false;
        
        // Task-specific triggers (like CUSTOMER_PICKUP sends SMS)
        if (auto.trigger_type === 'task_complete' && auto.trigger_value) {
          const triggerKeys = auto.trigger_value.split(',').map(k => k.trim().toUpperCase());
          if (triggerKeys.some(k => taskKey.toUpperCase().includes(k))) {
            shouldRun = true;
          }
        }
        
        if (shouldRun && invoice) {
          Logger.log('Running automation: ' + auto.automation_key);
          
          if (auto.target_field === 'sms_notification') {
            const smsResult = sendProductionSMS(invoice, taskKey, auto.new_value);
            automationsRun.push({ key: auto.automation_key, action: 'sms', result: smsResult });
          }
          
          if (auto.target_field === 'invoice_status') {
            updateInvoiceStatus(invoiceId, auto.new_value);
            automationsRun.push({ key: auto.automation_key, action: 'status_change', value: auto.new_value });
          }
        }
      }
    }
    
    Logger.log('Automations run: ' + JSON.stringify(automationsRun));
    Logger.log('All tasks complete: ' + allComplete);
    
    return { 
      ok: true, 
      automations_run: automationsRun,
      all_complete: allComplete,
      customer_name: invoice?.customer_name || '',
      invoice_id: invoiceId
    };
    
  } catch (error) {
    Logger.log('checkAndRunAutomations error: ' + error.toString());
    return { ok: false, error: error.toString(), all_complete: false };
  }
}

/**
 * Archive a production job (called when user confirms archive)
 */
function archiveProductionJob(invoiceId) {
  try {
    // Update bucket to ARCHIVE_WON
    updateDocumentBucket(invoiceId, 'ARCHIVE_WON');
    
    // Update status to Completed
    updateInvoiceStatus(invoiceId, 'Completed');
    
    Logger.log('Production job archived: ' + invoiceId);
    return { ok: true };
    
  } catch (error) {
    Logger.log('archiveProductionJob error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Update invoice status field
 */
function updateInvoiceStatus(invoiceId, newStatus) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const sheet = ss.getSheetByName('Documents');
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    const idCol = headers.indexOf('doc_id');
    const statusCol = headers.indexOf('status');
    
    for (let i = 1; i < data.length; i++) {
      if (String(data[i][idCol]) === String(invoiceId)) {
        sheet.getRange(i + 1, statusCol + 1).setValue(newStatus);
        Logger.log('Invoice ' + invoiceId + ' status updated to: ' + newStatus);
        return { ok: true };
      }
    }
    
    return { ok: false, error: 'Invoice not found' };
    
  } catch (error) {
    Logger.log('updateInvoiceStatus error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Send SMS notification for production milestone
 */
function sendProductionSMS(invoice, taskKey, messageTemplate) {
  try {
    const customerPhone = invoice.customer_phone;
    const customerName = invoice.customer_name || 'Customer';
    
    if (!customerPhone) {
      Logger.log('No phone number for invoice ' + invoice.doc_id);
      return { ok: false, error: 'No phone number' };
    }
    
    // Build message from template or use default
    let message = messageTemplate || '';
    
    // Replace placeholders
    message = message.replace('{customer_name}', customerName.split(' ')[0]);
    message = message.replace('{invoice_id}', invoice.doc_id);
    message = message.replace('{task}', taskKey);
    
    // Default messages based on task
    if (!message) {
      const taskUpper = taskKey.toUpperCase();
      if (taskUpper.includes('PICKUP') || taskUpper.includes('READY')) {
        message = 'Hi ' + customerName.split(' ')[0] + '! Your order is ready for pickup at Frederick Wraps. See you soon!';
      } else if (taskUpper.includes('SHIP') || taskUpper.includes('SHIPPED')) {
        message = 'Hi ' + customerName.split(' ')[0] + '! Your order has shipped. You should receive tracking info shortly.';
      } else {
        message = 'Hi ' + customerName.split(' ')[0] + '! Update on your order: ' + taskKey + ' is complete.';
      }
    }
    
    // Send via Twilio
    const result = sendTwilioSMS(customerPhone, message);
    
    Logger.log('Production SMS sent to ' + customerPhone + ': ' + message);
    return result;
    
  } catch (error) {
    Logger.log('sendProductionSMS error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Send SMS via Twilio
 */
function sendTwilioSMS(toPhone, message) {
  try {
    const specSs = SpreadsheetApp.openById(CONFIG.specSheetId);
    const helpersSheet = specSs.getSheetByName('HELPERS');
    
    if (!helpersSheet) {
      return { ok: false, error: 'HELPERS sheet not found' };
    }
    
    const helpersData = helpersSheet.getDataRange().getValues();
    let twilioSid = '';
    let twilioToken = '';
    let twilioFrom = '';
    
    for (let i = 0; i < helpersData.length; i++) {
      const key = String(helpersData[i][0]).toLowerCase();
      const value = helpersData[i][1];
      if (key === 'twilio_sid' || key === 'twilio_account_sid') twilioSid = value;
      if (key === 'twilio_token' || key === 'twilio_auth_token') twilioToken = value;
      if (key === 'twilio_from' || key === 'twilio_phone') twilioFrom = value;
    }
    
    if (!twilioSid || !twilioToken || !twilioFrom) {
      return { ok: false, error: 'Twilio not configured' };
    }
    
    // Format phone number
    let phone = String(toPhone).replace(/\D/g, '');
    if (phone.length === 10) phone = '1' + phone;
    phone = '+' + phone;
    
    const url = 'https://api.twilio.com/2010-04-01/Accounts/' + twilioSid + '/Messages.json';
    
    const response = UrlFetchApp.fetch(url, {
      method: 'post',
      headers: {
        'Authorization': 'Basic ' + Utilities.base64Encode(twilioSid + ':' + twilioToken)
      },
      payload: {
        'To': phone,
        'From': twilioFrom,
        'Body': message
      },
      muteHttpExceptions: true
    });
    
    const result = JSON.parse(response.getContentText());
    
    if (result.error_code) {
      return { ok: false, error: result.error_message };
    }
    
    return { ok: true, sid: result.sid };
    
  } catch (error) {
    Logger.log('sendTwilioSMS error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Update invoice status field
 */
function updateInvoiceStatus(invoiceId, newStatus) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const sheet = ss.getSheetByName('Documents');
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    const idCol = headers.indexOf('doc_id');
    const statusCol = headers.indexOf('status');
    
    for (let i = 1; i < data.length; i++) {
      if (String(data[i][idCol]) === String(invoiceId)) {
        sheet.getRange(i + 1, statusCol + 1).setValue(newStatus);
        Logger.log('Invoice ' + invoiceId + ' status updated to: ' + newStatus);
        return { ok: true };
      }
    }
    
    return { ok: false, error: 'Invoice not found' };
    
  } catch (error) {
    Logger.log('updateInvoiceStatus error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Archive a completed invoice (move to ARCHIVE_WON)
 */
function archiveCompletedInvoice(invoiceId) {
  try {
    // Update bucket to ARCHIVE_WON
    const bucketResult = updateDocumentBucket(invoiceId, 'ARCHIVE_WON');
    
    // Update status to Completed
    const statusResult = updateInvoiceStatus(invoiceId, 'Completed');
    
    Logger.log('Invoice ' + invoiceId + ' archived');
    return { ok: true };
    
  } catch (error) {
    Logger.log('archiveCompletedInvoice error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Send SMS notification for production milestone
 */
function sendProductionSMS(invoice, taskKey, messageTemplate) {
  try {
    const customerPhone = invoice.customer_phone;
    const customerName = invoice.customer_name || 'Customer';
    
    if (!customerPhone) {
      Logger.log('No phone number for invoice ' + invoice.doc_id);
      return { ok: false, error: 'No phone number' };
    }
    
    // Build message from template or use default
    let message = messageTemplate || '';
    
    // Replace placeholders
    message = message.replace('{customer_name}', customerName.split(' ')[0]); // First name
    message = message.replace('{invoice_id}', invoice.doc_id);
    message = message.replace('{task}', taskKey);
    
    // Default messages based on task
    if (!message) {
      const taskUpper = taskKey.toUpperCase();
      if (taskUpper.includes('PICKUP') || taskUpper.includes('READY')) {
        message = 'Hi ' + customerName.split(' ')[0] + '! Your order is ready for pickup at Frederick Wraps. See you soon!';
      } else if (taskUpper.includes('SHIP') || taskUpper.includes('SHIPPED')) {
        message = 'Hi ' + customerName.split(' ')[0] + '! Your order has shipped. You should receive tracking info shortly.';
      } else if (taskUpper.includes('COMPLETE') || taskUpper.includes('DONE')) {
        message = 'Hi ' + customerName.split(' ')[0] + '! Your project is complete. Thank you for choosing Frederick Wraps!';
      } else {
        message = 'Hi ' + customerName.split(' ')[0] + '! Update on your order: ' + taskKey + ' is complete.';
      }
    }
    
    // Send via Twilio (using existing sendSMS function if available)
    const result = sendTwilioSMS(customerPhone, message);
    
    Logger.log('Production SMS sent to ' + customerPhone + ': ' + message);
    return result;
    
  } catch (error) {
    Logger.log('sendProductionSMS error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Send SMS via Twilio
 */
function sendTwilioSMS(toPhone, message) {
  try {
    // Get Twilio credentials from HELPERS
    const specSs = SpreadsheetApp.openById(CONFIG.specSheetId);
    const helpersSheet = specSs.getSheetByName('HELPERS');
    
    if (!helpersSheet) {
      Logger.log('HELPERS sheet not found');
      return { ok: false, error: 'HELPERS sheet not found' };
    }
    
    const helpersData = helpersSheet.getDataRange().getValues();
    let twilioSid = '';
    let twilioToken = '';
    let twilioFrom = '';
    
    for (let i = 0; i < helpersData.length; i++) {
      const key = String(helpersData[i][0]).toLowerCase();
      const value = helpersData[i][1];
      if (key === 'twilio_sid' || key === 'twilio_account_sid') twilioSid = value;
      if (key === 'twilio_token' || key === 'twilio_auth_token') twilioToken = value;
      if (key === 'twilio_from' || key === 'twilio_phone') twilioFrom = value;
    }
    
    if (!twilioSid || !twilioToken || !twilioFrom) {
      Logger.log('Twilio credentials not configured');
      return { ok: false, error: 'Twilio not configured' };
    }
    
    // Format phone number
    let phone = String(toPhone).replace(/\D/g, '');
    if (phone.length === 10) {
      phone = '1' + phone;
    }
    phone = '+' + phone;
    
    // Send SMS
    const url = 'https://api.twilio.com/2010-04-01/Accounts/' + twilioSid + '/Messages.json';
    
    const response = UrlFetchApp.fetch(url, {
      method: 'post',
      headers: {
        'Authorization': 'Basic ' + Utilities.base64Encode(twilioSid + ':' + twilioToken)
      },
      payload: {
        'To': phone,
        'From': twilioFrom,
        'Body': message
      },
      muteHttpExceptions: true
    });
    
    const result = JSON.parse(response.getContentText());
    
    if (result.error_code) {
      Logger.log('Twilio error: ' + result.error_message);
      return { ok: false, error: result.error_message };
    }
    
    Logger.log('SMS sent: ' + result.sid);
    return { ok: true, sid: result.sid };
    
  } catch (error) {
    Logger.log('sendTwilioSMS error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * TEST: Test getProductionQueue
 */
function TEST_getProductionQueue() {
  const result = getProductionQueue();
  Logger.log('OK: ' + result.ok);
  if (result.error) {
    Logger.log('Error: ' + result.error);
  }
  Logger.log('Jobs count: ' + (result.jobs ? result.jobs.length : 0));
  if (result.jobs && result.jobs.length > 0) {
    result.jobs.forEach(job => {
      Logger.log('Job: ' + job.invoice_id + ' | ' + job.customer_name + ' | Tasks: ' + job.total_tasks);
    });
  }
}

/**
 * Bulk update task statuses (for drag-and-drop or quick actions)
 */
function bulkUpdateTaskStatus(taskIds, newStatus) {
  try {
    const results = [];
    
    for (const taskId of taskIds) {
      const result = updateProductionTask(taskId, { status: newStatus });
      results.push({ task_id: taskId, ...result });
    }
    
    const successCount = results.filter(r => r.ok).length;
    
    return {
      ok: true,
      updated: successCount,
      total: taskIds.length,
      results: results
    };
    
  } catch (error) {
    Logger.log('bulkUpdateTaskStatus error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

// ============================================================================
// STRIPE PAYMENT INTEGRATION
// ============================================================================

const STRIPE_WEBHOOK_SECRET = 'whsec_SP1KZDKfxD1TZkMZZXcnGWovy3508zfH';

/**
 * Get Stripe configuration from HELPERS sheet
 */
function getStripeConfig() {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.specSheetId);
    const sheet = ss.getSheetByName(CONFIG.specSheets.helpers);
    const data = sheet.getDataRange().getValues();
    
    const config = {};
    data.forEach(row => {
      if (row[0]) config[row[0]] = row[1];
    });
    
    // Check if test mode is enabled
    const testMode = String(config['StripeTestMode']).toUpperCase() === 'TRUE';
    
    return {
      testMode: testMode,
      secretKey: testMode ? (config['StripeTestSecretKey'] || '') : (config['StripeSecretKey'] || ''),
      publicKey: testMode ? (config['StripeTestPublicKey'] || '') : (config['StripePublicKey'] || ''),
      feePercent: parseFloat(config['StripeFeePercent']) || 0.029,
      feeFixed: parseFloat(config['StripeFeeFixed']) || 0.30
    };
    
  } catch (error) {
    Logger.log('getStripeConfig error: ' + error.toString());
    return null;
  }
}

/**
 * Handle Stripe webhook events
 */
function handleStripeWebhook(e) {
  try {
    Logger.log('=== STRIPE WEBHOOK RECEIVED ===');
    
    let event;
    
    // Parse the webhook payload
    if (e.postData && e.postData.contents) {
      event = JSON.parse(e.postData.contents);
    } else {
      Logger.log('No postData in webhook');
      return { ok: false, error: 'No payload' };
    }
    
    Logger.log('Event type: ' + event.type);
    Logger.log('Event ID: ' + event.id);
    
    // Handle payment_intent.succeeded
    if (event.type === 'payment_intent.succeeded') {
      const paymentIntent = event.data.object;
      return processSuccessfulPayment(paymentIntent);
    }
    
    // Handle checkout.session.completed
    if (event.type === 'checkout.session.completed') {
      const session = event.data.object;
      Logger.log('Checkout session completed: ' + session.id);
      // If using Checkout Sessions, handle here
      if (session.payment_intent) {
        // Fetch the payment intent details if needed
        return { ok: true, message: 'Checkout session noted, payment_intent event will handle recording' };
      }
    }
    
    Logger.log('Unhandled event type: ' + event.type);
    return { ok: true, message: 'Event type not handled: ' + event.type };
    
  } catch (error) {
    Logger.log('handleStripeWebhook error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Process a successful payment from Stripe
 */
function processSuccessfulPayment(paymentIntent) {
  try {
    Logger.log('Processing payment: ' + paymentIntent.id);
    Logger.log('Amount: ' + paymentIntent.amount + ' cents');
    Logger.log('Metadata: ' + JSON.stringify(paymentIntent.metadata));
    
    const txnId = paymentIntent.id;
    const amountCents = paymentIntent.amount;
    const amountDollars = amountCents / 100;
    
    // Get invoice/doc ID from metadata
    const docId = paymentIntent.metadata.doc_id || paymentIntent.metadata.invoice_id || '';
    const customerName = paymentIntent.metadata.customer_name || '';
    const customerEmail = paymentIntent.receipt_email || paymentIntent.metadata.customer_email || '';
    
    if (!docId) {
      Logger.log('WARNING: No doc_id in payment metadata');
      // Still record it, but flag it
    }
    
    // ========================================
    // DUPLICATE CHECK - CRITICAL!
    // ========================================
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const paymentsSheet = ss.getSheetByName('Payments');
    const paymentsData = paymentsSheet.getDataRange().getValues();
    const headers = paymentsData[0];
    const txnCol = headers.indexOf('processor_txn_id');
    
    // Check if this transaction already exists
    for (let i = 1; i < paymentsData.length; i++) {
      if (paymentsData[i][txnCol] === txnId) {
        Logger.log('DUPLICATE DETECTED: ' + txnId + ' already recorded at row ' + (i + 1));
        return { ok: true, message: 'Payment already recorded', duplicate: true };
      }
    }
    
    // ========================================
    // Calculate fees (fee was already added to amount charged)
    // ========================================
    const stripeConfig = getStripeConfig();
    const feePercent = stripeConfig ? stripeConfig.feePercent : 0.029;
    const feeFixed = stripeConfig ? stripeConfig.feeFixed : 0.30;
    
    // Work backwards: total charged includes fee, so invoice amount = total / (1 + feePercent) - feeFixed adjustment
    // Simpler: fee = (invoiceAmount * feePercent) + feeFixed, and we charged invoiceAmount + fee
    // So: amountDollars = invoiceAmount + fee
    // For recording, we want to record the INVOICE amount (what applies to balance), not the total charged
    const feeRounded = Math.round(((amountDollars - feeFixed) / (1 + feePercent)) * feePercent * 100 + feeFixed * 100) / 100;
    const invoiceAmount = amountDollars - feeRounded;
    const invoiceAmountRounded = Math.round(invoiceAmount * 100) / 100;
    
    // ========================================
    // Record the payment (record invoice amount, not total charged)
    // ========================================
    const paymentData = {
      amount: invoiceAmountRounded,
      payment_method: 'Credit Card',
      processor: 'Stripe',
      processor_txn_id: txnId,
      notes: 'Online payment via Stripe. Invoice: $' + invoiceAmountRounded.toFixed(2) + '. Fee paid by customer: $' + feeRounded.toFixed(2) + '. Total charged: $' + amountDollars.toFixed(2)
    };

    
    if (docId) {
      const result = recordPayment(docId, paymentData);
      Logger.log('Payment recorded: ' + JSON.stringify(result));
      
      // Send payment confirmation to customer
      if (result.ok) {
        sendPaymentConfirmation(docId, invoiceAmountRounded);
        
        // Generate production tasks for the paid invoice
        try {
          const prodResult = generateProductionTasks(docId);
          Logger.log('Production tasks result: ' + JSON.stringify(prodResult));
        } catch (prodError) {
          Logger.log('Production task generation error (non-fatal): ' + prodError.toString());
        }
      }
      
      return result;
    } else {
      // Record as unattached payment
      const paymentId = generatePaymentId();
      const now = new Date().toISOString();
      
      const newRow = [
        paymentId,
        now,
        '', // no doc_id
        amountDollars,
        'Credit Card',
        'Stripe',
        txnId,
        'Completed',
        paymentData.notes + ' | UNATTACHED - needs manual linking | Customer: ' + customerName + ' | Email: ' + customerEmail
      ];
      
      paymentsSheet.appendRow(newRow);
      Logger.log('Unattached payment recorded: ' + paymentId);
      
      return { ok: true, payment_id: paymentId, warning: 'No doc_id - payment recorded but unattached' };
    }
    
  } catch (error) {
    Logger.log('processSuccessfulPayment error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Send payment confirmation SMS and email to customer
 */
function sendPaymentConfirmation(docId, amount) {
  try {
    // Get document details
    const docResult = getDocumentById(docId);
    if (!docResult.ok) {
      Logger.log('Could not get document for confirmation: ' + docId);
      return;
    }
    
    const doc = docResult.document;
    const customerPhone = doc.customer_phone;
    const customerEmail = doc.customer_email;
    const customerName = doc.customer_name || 'Valued Customer';
    
    // Build the invoice link
    const baseUrl = ScriptApp.getService().getUrl();
    const invoiceLink = baseUrl + '?page=customer_document&id=' + docId;
    
    // Send SMS if phone exists
    if (customerPhone) {
      const phoneDigits = String(customerPhone).replace(/\D/g, '');
      if (phoneDigits.length >= 10) {
        const formattedPhone = phoneDigits.length === 10 ? '+1' + phoneDigits : '+' + phoneDigits;
        
        const smsBody = 'Frederick Wraps: Payment of $' + amount.toLocaleString() + ' received! Thank you. View your paid invoice: ' + invoiceLink;
        
        try {
          sendSMS(formattedPhone, smsBody);
          Logger.log('Payment confirmation SMS sent to: ' + formattedPhone);
        } catch (smsErr) {
          Logger.log('SMS send failed: ' + smsErr.toString());
        }
      }
    }
    
    // Send email if address exists
    if (customerEmail) {
      try {
        const subject = 'Payment Received - Frederick Wraps & Graphics';
        const htmlBody = `
          <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
            <h2 style="color: #d71cd1;">Payment Confirmed!</h2>
            <p>Hi ${customerName},</p>
            <p>We've received your payment of <strong>$${amount.toLocaleString()}</strong>. Thank you!</p>
            <p><a href="${invoiceLink}" style="display: inline-block; padding: 12px 24px; background: #d71cd1; color: white; text-decoration: none; border-radius: 8px; margin: 16px 0;">View Your Paid Invoice</a></p>
            <p style="color: #666; font-size: 14px;">If you have any questions, reply to this email or call us at (240) 693-3715.</p>
            <p>Thanks for choosing Frederick Wraps & Graphics!</p>
          </div>
        `;
        
        GmailApp.sendEmail(customerEmail, subject, 'Payment of $' + amount.toLocaleString() + ' received. View invoice: ' + invoiceLink, {
          htmlBody: htmlBody,
          name: 'Frederick Wraps & Graphics'
        });
        Logger.log('Payment confirmation email sent to: ' + customerEmail);
      } catch (emailErr) {
        Logger.log('Email send failed: ' + emailErr.toString());
      }
    }
    
  } catch (error) {
    Logger.log('sendPaymentConfirmation error: ' + error.toString());
    // Don't throw - this is a non-critical notification
  }
}

/**
 * Send document notification via SMS and/or Email
 * Stores send options on document for customer-facing page to use
 */
function sendDocumentNotification(docId, options) {
  try {
    // Get document details
    const docResult = getDocumentById(docId);
    if (!docResult.ok) {
      return { ok: false, error: 'Document not found: ' + docId };
    }
    
    const doc = docResult.document;
    const customerPhone = doc.customer_phone;
    const customerEmail = doc.customer_email;
    const customerName = doc.customer_name || 'Valued Customer';
    const isQuote = doc.doc_type === 'quote';
    const docTypeLabel = isQuote ? 'quote' : 'invoice';
    
    // Calculate payment amount based on terms
    const total = Number(doc.total) || 0;
    let paymentAmount = total;
    if (options.paymentTerms === 'deposit_50') {
      paymentAmount = Math.round(total * 0.5 * 100) / 100;
    } else if (options.paymentTerms === 'custom' && options.customPaymentAmount) {
      paymentAmount = Number(options.customPaymentAmount);
    }
    
    // Build the customer link
    const baseUrl = ScriptApp.getService().getUrl();
    const customerLink = baseUrl + '?page=customer_document&id=' + docId;
    
    let smsSent = false;
    let emailSent = false;
    
    // Send SMS if enabled and phone exists
    if (options.sms && customerPhone) {
      const phoneDigits = String(customerPhone).replace(/\D/g, '');
      if (phoneDigits.length >= 10) {
        const formattedPhone = phoneDigits.length === 10 ? '+1' + phoneDigits : '+' + phoneDigits;
        
        const smsBody = 'Frederick Wraps: Your ' + docTypeLabel + ' for $' + total.toLocaleString() + ' is ready for review. View here: ' + customerLink;
        
        try {
          sendSMS(formattedPhone, smsBody);
          smsSent = true;
          Logger.log('Document notification SMS sent to: ' + formattedPhone);
        } catch (smsErr) {
          Logger.log('SMS send failed: ' + smsErr.toString());
        }
      }
    }
    
    // Send email if enabled and address exists
    if (options.email && customerEmail) {
      try {
        const subject = 'Your ' + (isQuote ? 'Quote' : 'Invoice') + ' from Frederick Wraps & Graphics';
        const htmlBody = buildDocumentEmailHtml(doc, customerLink, docTypeLabel);
        
        GmailApp.sendEmail(customerEmail, subject, 
          'Your ' + docTypeLabel + ' for $' + total.toLocaleString() + ' is ready. View: ' + customerLink, 
          {
            htmlBody: htmlBody,
            name: 'Frederick Wraps & Graphics'
          }
        );
        emailSent = true;
        Logger.log('Document notification email sent to: ' + customerEmail);
      } catch (emailErr) {
        Logger.log('Email send failed: ' + emailErr.toString());
      }
    }
    
    // Update document with send options and status
    if (smsSent || emailSent) {
      const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
      const sheet = ss.getSheetByName('Documents');
      const data = sheet.getDataRange().getValues();
      const headers = data[0];
      
      const docIdCol = headers.indexOf('doc_id');
      const statusCol = headers.indexOf('status');
      const sentAtCol = headers.indexOf('sent_at');
      const depositRequiredCol = headers.indexOf('deposit_required');
      const sendOptionsCol = headers.indexOf('send_options_json');
      
      for (let i = 1; i < data.length; i++) {
        if (String(data[i][docIdCol]) === String(docId)) {
          // Only update status if currently Draft
          if (data[i][statusCol] === 'Draft') {
            sheet.getRange(i + 1, statusCol + 1).setValue('Sent');
          }
          sheet.getRange(i + 1, sentAtCol + 1).setValue(new Date().toISOString());
          
          // Store payment amount in deposit_required field
          if (depositRequiredCol !== -1) {
            sheet.getRange(i + 1, depositRequiredCol + 1).setValue(paymentAmount);
          }
          
          // Store full send options as JSON if column exists
          if (sendOptionsCol !== -1) {
            const sendOptions = {
              approvalType: options.approvalType || null,
              customApprovalText: options.customApprovalText || null,
              paymentTerms: options.paymentTerms || 'full',
              paymentAmount: paymentAmount,
              includeLineAttachments: options.includeLineAttachments !== false,
              includeProjectAttachments: options.includeProjectAttachments === true,
              customerNotificationPref: options.customerNotificationPref || 'sms',
              sentVia: { sms: smsSent, email: emailSent }
            };
            sheet.getRange(i + 1, sendOptionsCol + 1).setValue(JSON.stringify(sendOptions));
          }
          
          break;
        }
      }
    }
    
    return { 
      ok: true, 
      smsSent: smsSent, 
      emailSent: emailSent,
      paymentAmount: paymentAmount,
      message: (smsSent ? 'SMS sent. ' : '') + (emailSent ? 'Email sent.' : '')
    };
    
  } catch (error) {
    Logger.log('sendDocumentNotification error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Build HTML email body for document notification
 */
function buildDocumentEmailHtml(doc, customerLink, docTypeLabel) {
  const total = Number(doc.total) || 0;
  const isQuote = doc.doc_type === 'quote';
  
  return `
    <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 600px; margin: 0 auto; background: #1e293b; color: #f1f5f9; padding: 32px; border-radius: 12px;">
      <div style="text-align: center; margin-bottom: 24px;">
        <h1 style="color: #d71cd1; margin: 0; font-size: 24px;">Frederick Wraps & Graphics</h1>
        <p style="color: #94a3b8; margin: 8px 0 0 0;">Professional Vehicle Wraps & Graphics</p>
      </div>
      
      <div style="background: #334155; padding: 24px; border-radius: 8px; margin-bottom: 24px;">
        <h2 style="margin: 0 0 16px 0; font-size: 18px;">Your ${isQuote ? 'Quote' : 'Invoice'} is Ready</h2>
        <p style="color: #94a3b8; margin: 0 0 8px 0;">Hi ${doc.customer_name || 'there'},</p>
        <p style="color: #94a3b8; margin: 0;">We've prepared a ${docTypeLabel} for your review.</p>
      </div>
      
      <div style="background: linear-gradient(135deg, #d71cd1, #02f9fb); padding: 20px; border-radius: 8px; text-align: center; margin-bottom: 24px;">
        <div style="font-size: 14px; opacity: 0.9;">Total</div>
        <div style="font-size: 36px; font-weight: 700;">$${total.toLocaleString()}</div>
      </div>
      
      ${doc.vehicle_description ? `<p style="color: #94a3b8; margin: 0 0 8px 0;"><strong>Vehicle:</strong> ${doc.vehicle_description}</p>` : ''}
      ${doc.project_description ? `<p style="color: #94a3b8; margin: 0 0 16px 0;"><strong>Project:</strong> ${doc.project_description}</p>` : ''}
      
      <div style="text-align: center; margin: 32px 0;">
        <a href="${customerLink}" style="display: inline-block; padding: 16px 32px; background: #d71cd1; color: white; text-decoration: none; border-radius: 8px; font-weight: 600; font-size: 16px;">View ${isQuote ? 'Quote' : 'Invoice'}</a>
      </div>
      
      <div style="border-top: 1px solid #475569; padding-top: 24px; text-align: center; color: #64748b; font-size: 14px;">
        <p style="margin: 0 0 8px 0;">Questions? Contact us:</p>
        <p style="margin: 0;">(240) 693-3715 | info@frederickwraps.com</p>
      </div>
    </div>
  `;
}

/**
 * Generate a payment ID
 */
function generatePaymentId() {
  const now = new Date();
  const yy = String(now.getFullYear()).slice(-2);
  const mm = String(now.getMonth() + 1).padStart(2, '0');
  const dd = String(now.getDate()).padStart(2, '0');
  const random = Math.floor(Math.random() * 1000).toString().padStart(3, '0');
  return yy + mm + dd + '-' + random;
}

/**
 * Create a Stripe PaymentIntent for customer payment
 */
function createStripePaymentIntent(docId, amount, customerEmail, customerName) {
  try {
    const stripeConfig = getStripeConfig();
    if (!stripeConfig || !stripeConfig.secretKey) {
      return { ok: false, error: 'Stripe not configured' };
    }
    
    // Calculate processing fee (customer pays the fee)
    const feePercent = stripeConfig.feePercent || 0.029;
    const feeFixed = stripeConfig.feeFixed || 0.30;
    const processingFee = (amount * feePercent) + feeFixed;
    const processingFeeRounded = Math.round(processingFee * 100) / 100;
    const totalWithFee = amount + processingFeeRounded;
    
    Logger.log('Creating PaymentIntent for doc: ' + docId);
    Logger.log('Invoice amount: $' + amount);
    Logger.log('Processing fee: $' + processingFeeRounded);
    Logger.log('Total to charge: $' + totalWithFee);
    
    const amountCents = Math.round(totalWithFee * 100);
    
    const payload = {
      'amount': amountCents.toString(),
      'currency': 'usd',
      'receipt_email': customerEmail,
      'metadata[doc_id]': docId,
      'metadata[customer_name]': customerName,
      'metadata[customer_email]': customerEmail
    };
    
    // Convert to URL-encoded string
    const formData = Object.keys(payload)
      .map(key => encodeURIComponent(key) + '=' + encodeURIComponent(payload[key]))
      .join('&');
    
    const response = UrlFetchApp.fetch('https://api.stripe.com/v1/payment_intents', {
      method: 'post',
      headers: {
        'Authorization': 'Basic ' + Utilities.base64Encode(stripeConfig.secretKey + ':'),
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      payload: formData,
      muteHttpExceptions: true
    });
    
    const result = JSON.parse(response.getContentText());
    
    if (result.error) {
      Logger.log('Stripe error: ' + result.error.message);
      return { ok: false, error: result.error.message };
    }
    
    Logger.log('PaymentIntent created: ' + result.id);
    
    return {
      ok: true,
      clientSecret: result.client_secret,
      paymentIntentId: result.id,
      invoiceAmount: amount,
      processingFee: processingFeeRounded,
      totalAmount: totalWithFee,
      publicKey: stripeConfig.publicKey
    };
    
  } catch (error) {
    Logger.log('createStripePaymentIntent error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Test function for Stripe config
 */
function TEST_stripeConfig() {
  const config = getStripeConfig();
  Logger.log('Stripe Config:');
  Logger.log('- Public Key: ' + (config.publicKey ? config.publicKey.substring(0, 20) + '...' : 'NOT SET'));
  Logger.log('- Secret Key: ' + (config.secretKey ? config.secretKey.substring(0, 20) + '...' : 'NOT SET'));
  Logger.log('- Fee Percent: ' + config.feePercent);
  Logger.log('- Fee Fixed: $' + config.feeFixed);
  return config;
}

/**
 * Test function to check document save
 */
function TEST_documentSave() {
  // Get a recent document
  const docs = sheetToObjects('Documents');
  if (docs.length === 0) {
    Logger.log('No documents found');
    return;
  }
  
  const testDoc = docs[0];
  Logger.log('=== TEST DOCUMENT SAVE ===');
  Logger.log('Doc ID: ' + testDoc.doc_id);
  Logger.log('Current total: ' + testDoc.total);
  
  // Get line items for this doc
  const lineItems = sheetToObjects('DocumentLineItems');
  const docLineItems = lineItems.filter(li => li.doc_id === testDoc.doc_id);
  Logger.log('Line items count: ' + docLineItems.length);
  docLineItems.forEach((li, i) => {
    Logger.log('  Line ' + i + ': qty=' + li.quantity + ', price=' + li.unit_price + ', total=' + li.line_total);
  });
  
  return { doc: testDoc, lineItems: docLineItems };
}

/**
 * Test to check if updateDocument updates totals
 */
function TEST_checkDocumentTotals() {
  const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
  
  // Check Documents sheet
  const docsSheet = ss.getSheetByName('Documents');
  const docsData = docsSheet.getDataRange().getValues();
  const docsHeaders = docsData[0];
  
  Logger.log('=== DOCUMENTS SHEET COLUMNS ===');
  Logger.log('Headers: ' + docsHeaders.join(', '));
  
  const totalCol = docsHeaders.indexOf('total');
  const subtotalCol = docsHeaders.indexOf('subtotal');
  
  Logger.log('total column index: ' + totalCol);
  Logger.log('subtotal column index: ' + subtotalCol);
  
  // Show first doc's values
  if (docsData.length > 1) {
    Logger.log('First doc total value: ' + docsData[1][totalCol]);
    Logger.log('First doc subtotal value: ' + docsData[1][subtotalCol]);
  }
  
  // Check DocumentLineItems
  const lineSheet = ss.getSheetByName('DocumentLineItems');
  const lineData = lineSheet.getDataRange().getValues();
  const lineHeaders = lineData[0];
  
  Logger.log('=== LINE ITEMS COLUMNS ===');
  Logger.log('Headers: ' + lineHeaders.join(', '));
}

/**
 * Test what updateDocument receives and does
 */
function TEST_updateDocumentTrace() {
  // Simulate what the frontend sends
  const testDocId = '1001';  // Use your actual doc_id
  const testData = {
    doc_id: testDocId,
    subtotal: 9999,  // Test value
    total: 8888,     // Test value
    line_items: [
      { line_id: '', description: 'Test', quantity: 10, unit_price: 100, line_total: 1000 }
    ]
  };
  
  Logger.log('=== CALLING updateDocument ===');
  Logger.log('Doc ID: ' + testDocId);
  Logger.log('Subtotal being sent: ' + testData.subtotal);
  Logger.log('Total being sent: ' + testData.total);
  
  const result = updateDocument(testDocId, testData);
  
  Logger.log('Result: ' + JSON.stringify(result));
  
  // Now check what's actually in the sheet
  const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
  const sheet = ss.getSheetByName('Documents');
  const data = sheet.getDataRange().getValues();
  const headers = data[0];
  
  const idCol = headers.indexOf('doc_id');
  const totalCol = headers.indexOf('total');
  const subtotalCol = headers.indexOf('subtotal');
  
  for (let i = 1; i < data.length; i++) {
    if (String(data[i][idCol]) === String(testDocId)) {
      Logger.log('=== AFTER SAVE - VALUES IN SHEET ===');
      Logger.log('Subtotal in sheet: ' + data[i][subtotalCol]);
      Logger.log('Total in sheet: ' + data[i][totalCol]);
      break;
    }
  }
}

function TEST_checkLineItemsSave() {
  const testDocId = '1001';
  
  // Check line items BEFORE
  const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
  const lineSheet = ss.getSheetByName('DocumentLineItems');
  const lineData = lineSheet.getDataRange().getValues();
  const headers = lineData[0];
  const docIdCol = headers.indexOf('doc_id');
  const qtyCol = headers.indexOf('quantity');
  const priceCol = headers.indexOf('unit_price');
  const totalCol = headers.indexOf('line_total');
  
  Logger.log('=== BEFORE UPDATE ===');
  for (let i = 1; i < lineData.length; i++) {
    if (String(lineData[i][docIdCol]) === testDocId) {
      Logger.log('Row ' + (i+1) + ': qty=' + lineData[i][qtyCol] + ', price=' + lineData[i][priceCol] + ', total=' + lineData[i][totalCol]);
    }
  }
  
  // Now call updateDocument with test line items
  const testData = {
    line_items: [
      { line_id: '', description: 'TEST ITEM', category: 'Other', quantity: 777, unit_price: 10, line_total: 7770 }
    ],
    subtotal: 7770,
    total: 7770
  };
  
  Logger.log('=== CALLING updateDocument ===');
  const result = updateDocument(testDocId, testData);
  Logger.log('Result: ' + JSON.stringify(result));
  
  // Check line items AFTER
  const lineData2 = lineSheet.getDataRange().getValues();
  Logger.log('=== AFTER UPDATE ===');
  for (let i = 1; i < lineData2.length; i++) {
    if (String(lineData2[i][docIdCol]) === testDocId) {
      Logger.log('Row ' + (i+1) + ': qty=' + lineData2[i][qtyCol] + ', price=' + lineData2[i][priceCol] + ', total=' + lineData2[i][totalCol]);
    }
  }
}

function TEST_checkRecentPayments() {
  const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
  const sheet = ss.getSheetByName('Payments');
  const data = sheet.getDataRange().getValues();
  
  Logger.log('=== ALL PAYMENTS ===');
  Logger.log('Total rows: ' + (data.length - 1));
  
  // Show last 5 payments
  const headers = data[0];
  for (let i = Math.max(1, data.length - 5); i < data.length; i++) {
    Logger.log('---');
    Logger.log('Row ' + i + ':');
    headers.forEach((h, j) => {
      if (data[i][j]) Logger.log('  ' + h + ': ' + data[i][j]);
    });
  }
}

function TEST_simulateStripeWebhook() {
  // Simulate the event object that doPost receives
  const fakeStripeEvent = {
    type: 'payment_intent.succeeded',
    id: 'evt_test_' + Date.now(),
    data: {
      object: {
        id: 'pi_test_' + Date.now(),
        amount: 1000, // $10.00 in cents
        receipt_email: 'joe@test.com',
        metadata: {
          doc_id: '1001',
          customer_name: 'Test Customer',
          customer_email: 'joe@test.com'
        }
      }
    }
  };
  
  // Simulate the e object that doPost receives
  const fakeE = {
    postData: {
      contents: JSON.stringify(fakeStripeEvent)
    },
    parameter: {}
  };
  
  Logger.log('=== SIMULATING STRIPE WEBHOOK ===');
  Logger.log('Fake event: ' + JSON.stringify(fakeStripeEvent, null, 2));
  
  const result = handleStripeWebhook(fakeE);
  
  Logger.log('=== RESULT ===');
  Logger.log(JSON.stringify(result, null, 2));
  
  // Check if payment was recorded
  const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
  const sheet = ss.getSheetByName('Payments');
  const data = sheet.getDataRange().getValues();
  Logger.log('=== PAYMENTS AFTER ===');
  Logger.log('Total payments: ' + (data.length - 1));
  if (data.length > 1) {
    Logger.log('Last payment: ' + JSON.stringify(data[data.length - 1]));
  }
}

function TEST_checkRecentPayments() {
  const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
  const sheet = ss.getSheetByName('Payments');
  const data = sheet.getDataRange().getValues();
  
  Logger.log('=== ALL PAYMENTS ===');
  Logger.log('Total rows: ' + (data.length - 1));
  
  // Show all payments
  const headers = data[0];
  for (let i = 1; i < data.length; i++) {
    Logger.log('---');
    Logger.log('Row ' + i + ':');
    headers.forEach((h, j) => {
      if (data[i][j]) Logger.log('  ' + h + ': ' + data[i][j]);
    });
  }
}

function TEST_checkHelpersKeys() {
  const ss = SpreadsheetApp.openById(CONFIG.specSheetId);
  const sheet = ss.getSheetByName(CONFIG.specSheets.helpers);
  const data = sheet.getDataRange().getValues();
  
  Logger.log('=== ALL HELPERS KEYS ===');
  data.forEach((row, i) => {
    if (row[0] && String(row[0]).includes('Stripe')) {
      Logger.log('Row ' + (i+1) + ': "' + row[0] + '" = "' + String(row[1]).substring(0, 30) + '..."');
    }
  });
}

/**
 * TEST: Diagnose SMS sending
 */
function TEST_sendSMS() {
  const testPhone = '+12407518588'; // Your test number
  const testMessage = 'FWG Test: SMS diagnostic at ' + new Date().toLocaleTimeString();
  
  Logger.log('=== SMS DIAGNOSTIC TEST ===');
  Logger.log('To: ' + testPhone);
  Logger.log('Message: ' + testMessage);
  
  try {
    const result = sendSMS(testPhone, testMessage);
    Logger.log('Result: ' + JSON.stringify(result));
    return result;
  } catch (error) {
    Logger.log('Error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * TEST: Diagnose sendDocumentNotification
 */
function TEST_sendDocumentNotification() {
  const testDocId = '1005'; // Use your latest quote/invoice doc_id
  
  Logger.log('=== TEST: sendDocumentNotification ===');
  Logger.log('Doc ID: ' + testDocId);
  
  // First check if document exists
  const docResult = getDocumentById(testDocId);
  Logger.log('Document found: ' + docResult.ok);
  
  if (docResult.ok) {
    const doc = docResult.document;
    Logger.log('Customer Name: ' + doc.customer_name);
    Logger.log('Customer Phone: ' + doc.customer_phone);
    Logger.log('Customer Email: ' + doc.customer_email);
    Logger.log('Doc Type: ' + doc.doc_type);
    Logger.log('Total: ' + doc.total);
  } else {
    Logger.log('Error: ' + docResult.error);
    return;
  }
  
  // Now try sending
  Logger.log('--- Attempting to send ---');
  const result = sendDocumentNotification(testDocId, { sms: true, email: true });
  Logger.log('Result: ' + JSON.stringify(result));
  
  return result;
}

function TEST_CommandCenterMetrics() {
  const result = getCommandCenterMetrics();
  Logger.log('Command Center Metrics:');
  Logger.log(JSON.stringify(result, null, 2));
}

function testGetTasks() {
  Logger.log('=== Testing getTasks ===');
  
  // Test 1: Check if CONFIG exists
  Logger.log('CONFIG.opsSheetId: ' + CONFIG.opsSheetId);
  
  // Test 2: Try to open the sheet
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    Logger.log('Spreadsheet opened: ' + ss.getName());
    
    const sheet = ss.getSheetByName('Tasks');
    if (sheet) {
      Logger.log('Tasks sheet found');
      Logger.log('Row count: ' + sheet.getLastRow());
      
      const data = sheet.getDataRange().getValues();
      Logger.log('Headers: ' + JSON.stringify(data[0]));
      
      if (data.length > 1) {
        Logger.log('First task row: ' + JSON.stringify(data[1]));
      }
    } else {
      Logger.log('ERROR: Tasks sheet not found');
    }
  } catch (e) {
    Logger.log('ERROR: ' + e.toString());
  }
  
  // Test 3: Call the actual function
  Logger.log('--- Calling getTasks ---');
  const result = getTasks({ status: 'active' });
  Logger.log('Result: ' + JSON.stringify(result));
}

/**
 * Wrapper for getTasks - testing naming issue
 */
function getTaskList(options) {
  Logger.log('getTaskList wrapper called');
  return getTasks(options);
}

/**
 * Update an existing task
 */
function updateTask(taskData) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const sheet = ss.getSheetByName('Tasks');
    
    if (!sheet) {
      return { ok: false, error: 'Tasks sheet not found' };
    }
    
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    
    // Find the task row
    const taskIdCol = headers.indexOf('task_id');
    let rowIndex = -1;
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][taskIdCol] === taskData.task_id) {
        rowIndex = i + 1; // 1-indexed for sheet
        break;
      }
    }
    
    if (rowIndex === -1) {
      return { ok: false, error: 'Task not found' };
    }
    
    // Update fields
    const colMap = {};
    headers.forEach((h, i) => colMap[h] = i + 1);
    
    if (taskData.title !== undefined) {
      sheet.getRange(rowIndex, colMap['title']).setValue(taskData.title);
    }
    if (taskData.description !== undefined) {
      sheet.getRange(rowIndex, colMap['description']).setValue(taskData.description);
    }
    if (taskData.status !== undefined) {
      sheet.getRange(rowIndex, colMap['status']).setValue(taskData.status);
      // If completed, set completed_at
      if (taskData.status === 'COMPLETED' || taskData.status === 'DONE') {
        sheet.getRange(rowIndex, colMap['completed_at']).setValue(new Date());
      }
    }
    if (taskData.priority !== undefined) {
      sheet.getRange(rowIndex, colMap['priority']).setValue(taskData.priority);
    }
    if (taskData.due_date !== undefined) {
      sheet.getRange(rowIndex, colMap['due_date']).setValue(taskData.due_date || '');
    }
    
    Logger.log('Task updated: ' + taskData.task_id);
    return { ok: true };
    
  } catch (error) {
    Logger.log('updateTask error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Delete a task
 */
function deleteTask(taskId) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const sheet = ss.getSheetByName('Tasks');
    
    if (!sheet) {
      return { ok: false, error: 'Tasks sheet not found' };
    }
    
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    const taskIdCol = headers.indexOf('task_id');
    
    // Find and delete the task row
    for (let i = 1; i < data.length; i++) {
      if (data[i][taskIdCol] === taskId) {
        sheet.deleteRow(i + 1);
        Logger.log('Task deleted: ' + taskId);
        return { ok: true };
      }
    }
    
    return { ok: false, error: 'Task not found' };
    
  } catch (error) {
    Logger.log('deleteTask error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Get all pinned items
 */
function getPinnedItems() {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const sheet = ss.getSheetByName('PinnedItems');
    
    if (!sheet || sheet.getLastRow() < 2) {
      return { ok: true, pinned: [] };
    }
    
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    const pinned = [];
    
    for (let i = 1; i < data.length; i++) {
      if (!data[i][0]) continue;
      const item = {};
      headers.forEach((h, col) => {
        const val = data[i][col];
        // Convert Date objects to ISO strings for serialization
        if (val instanceof Date) {
          item[h] = val.toISOString();
        } else {
          item[h] = val;
        }
      });
      pinned.push(item);
    }
    
    return { ok: true, pinned: pinned };
    
  } catch (error) {
    Logger.log('getPinnedItems error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Pin an item to top of priority queue
 */
function pinItem(itemType, itemId) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    let sheet = ss.getSheetByName('PinnedItems');
    
    // Create sheet if it doesn't exist
    if (!sheet) {
      sheet = ss.insertSheet('PinnedItems');
      sheet.getRange(1, 1, 1, 3).setValues([['item_type', 'item_id', 'pinned_at']]);
    }
    
    // Check if already pinned
    const data = sheet.getDataRange().getValues();
    for (let i = 1; i < data.length; i++) {
      if (data[i][0] === itemType && data[i][1].toString() === itemId.toString()) {
        return { ok: true, message: 'Already pinned' };
      }
    }
    
    // Add pin
    sheet.appendRow([itemType, itemId.toString(), new Date()]);
    Logger.log('Pinned: ' + itemType + ' ' + itemId);
    
    return { ok: true };
    
  } catch (error) {
    Logger.log('pinItem error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Unpin an item
 */
function unpinItem(itemType, itemId) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const sheet = ss.getSheetByName('PinnedItems');
    
    if (!sheet) {
      return { ok: true };
    }
    
    const data = sheet.getDataRange().getValues();
    for (let i = 1; i < data.length; i++) {
      if (data[i][0] === itemType && data[i][1].toString() === itemId.toString()) {
        sheet.deleteRow(i + 1);
        Logger.log('Unpinned: ' + itemType + ' ' + itemId);
        return { ok: true };
      }
    }
    
    return { ok: true };
    
  } catch (error) {
    Logger.log('unpinItem error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

function testPinning() {
  Logger.log('=== Testing Pinning ===');
  
  // Test 1: Check if sheet exists
  const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
  const sheet = ss.getSheetByName('PinnedItems');
  
  if (!sheet) {
    Logger.log('ERROR: PinnedItems sheet does not exist');
    return;
  }
  
  Logger.log('PinnedItems sheet found');
  Logger.log('Row count: ' + sheet.getLastRow());
  
  // Show all data
  const data = sheet.getDataRange().getValues();
  Logger.log('Headers: ' + JSON.stringify(data[0]));
  for (let i = 1; i < data.length; i++) {
    Logger.log('Row ' + i + ': ' + JSON.stringify(data[i]));
  }
  
  // Test 2: Try pinning something
  Logger.log('--- Testing pinItem ---');
  const pinResult = pinItem('task', 'TEST-123');
  Logger.log('pinItem result: ' + JSON.stringify(pinResult));
  
  // Test 3: Read it back
  Logger.log('--- Testing getPinnedItems ---');
  const getResult = getPinnedItems();
  Logger.log('getPinnedItems result: ' + JSON.stringify(getResult));
  
  // Test 4: Check sheet again
  const data2 = sheet.getDataRange().getValues();
  Logger.log('After pin - Row count: ' + sheet.getLastRow());
  for (let i = 1; i < data2.length; i++) {
    Logger.log('Row ' + i + ': ' + JSON.stringify(data2[i]));
  }
}

/**
 * Update the bucket for a document (quote or invoice)
 */
function updateDocumentBucket(docId, bucket) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const sheet = ss.getSheetByName('Documents');
    
    if (!sheet) {
      return { ok: false, error: 'Documents sheet not found' };
    }
    
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    const docIdCol = headers.indexOf('doc_id');
    const bucketCol = headers.indexOf('bucket');
    
    if (bucketCol === -1) {
      return { ok: false, error: 'bucket column not found in Documents sheet' };
    }
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][docIdCol] == docId) {
        sheet.getRange(i + 1, bucketCol + 1).setValue(bucket);
        Logger.log('Updated bucket for doc ' + docId + ' to ' + bucket);
        return { ok: true };
      }
    }
    
    return { ok: false, error: 'Document not found: ' + docId };
    
  } catch (error) {
    Logger.log('updateDocumentBucket error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Send a follow-up message for a quote or invoice
 * Optionally applies a discount incentive with expiration
 */
function sendFollowUp(docId, options) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const sheet = ss.getSheetByName('Documents');
    
    if (!sheet) {
      return { ok: false, error: 'Documents sheet not found' };
    }
    
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    
    // Build column map
    const colMap = {};
    headers.forEach((h, i) => colMap[h] = i);
    
    // Find the document row
    let rowIndex = -1;
    let doc = null;
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][colMap['doc_id']] == docId) {
        rowIndex = i + 1;
        doc = {};
        headers.forEach((h, col) => {
          doc[h] = data[i][col];
        });
        break;
      }
    }
    
    if (!doc) {
      return { ok: false, error: 'Document not found' };
    }
    
    // Get customer info
    const customerName = doc.customer_name || 'Customer';
    const customerPhone = doc.customer_phone;
    const firstName = customerName.split(' ')[0];
    const docType = doc.doc_type || 'quote';
    
    if (!customerPhone) {
      return { ok: false, error: 'No phone number on file' };
    }
    
    // Apply incentive if provided
    if (options.incentive) {
      const discountPercent = Number(options.incentive.percent) || 0;
      const expiresAt = options.incentive.expiresAt;
      const expiryDays = options.incentive.expiryDays || 7;
      
      // Update discount fields
      if (colMap['discount_percent'] !== undefined) {
        sheet.getRange(rowIndex, colMap['discount_percent'] + 1).setValue(discountPercent);
      }
      
      // Build discount note with expiry info
      const discountNote = 'Follow-up incentive: ' + discountPercent + '% off - Expires ' + expiresAt;
      if (colMap['discount_note'] !== undefined) {
        sheet.getRange(rowIndex, colMap['discount_note'] + 1).setValue(discountNote);
      }
      
      // Update valid_until
      if (colMap['valid_until'] !== undefined && expiresAt) {
        sheet.getRange(rowIndex, colMap['valid_until'] + 1).setValue(expiresAt);
      }
      
      // Recalculate discount amount and total
      const subtotal = Number(doc.subtotal) || 0;
      const discountAmount = Math.round(subtotal * discountPercent) / 100;
      const taxAmount = Number(doc.tax_amount) || 0;
      const newTotal = subtotal - discountAmount + taxAmount;
      const amountPaid = Number(doc.amount_paid) || 0;
      const newBalance = newTotal - amountPaid;
      
      if (colMap['discount_amount'] !== undefined) {
        sheet.getRange(rowIndex, colMap['discount_amount'] + 1).setValue(discountAmount);
      }
      if (colMap['total'] !== undefined) {
        sheet.getRange(rowIndex, colMap['total'] + 1).setValue(newTotal);
      }
      if (colMap['balance_due'] !== undefined) {
        sheet.getRange(rowIndex, colMap['balance_due'] + 1).setValue(newBalance);
      }
    }
    
    // Increment follow-up count
    const currentCount = Number(doc.followup_count) || 0;
    if (colMap['followup_count'] !== undefined) {
      sheet.getRange(rowIndex, colMap['followup_count'] + 1).setValue(currentCount + 1);
    }
    
    // Build the message
    const baseUrl = getWebAppUrl();
    const docLink = baseUrl + '?page=customer_document&id=' + docId;
    
    let message = '';
    
    if (options.customMessage) {
      message = options.customMessage;
    } else if (options.templateKey === 'CHECKING_IN') {
      message = 'Hi ' + firstName + ', just checking in on the ' + docType + ' we sent over. Let me know if you have any questions!';
    } else if (options.templateKey === 'READY_TO_PROCEED') {
      message = 'Hi ' + firstName + ', wanted to follow up on your ' + docType + '. We\'re ready to get started whenever works for you.';
    } else {
      message = 'Hi ' + firstName + ', following up on your ' + docType + '. Let us know if you have any questions!';
    }
    
    // Add incentive info to message if applicable
    if (options.incentive) {
      const discountPercent = options.incentive.percent;
      const expiryDays = options.incentive.expiryDays || 7;
      message += '\n\n🎉 Limited time offer: ' + discountPercent + '% off if you approve within ' + expiryDays + ' days!';
    }
    
    // Add link
    message += '\n\nView your ' + docType + ': ' + docLink;
    
    // Send SMS
    let smsSent = false;
    try {
      const formattedPhone = formatPhoneForTwilio(customerPhone);
      sendSMS(formattedPhone, message);
      smsSent = true;
      
      // Log the message
      logMessage({
        direction: 'outbound',
        channel: 'sms',
        customer_phone: formattedPhone,
        customer_name: customerName,
        quote_id: docType === 'quote' ? docId : null,
        invoice_id: docType === 'invoice' ? docId : null,
        message_body: message,
        status: 'sent'
      });
    } catch (smsError) {
      Logger.log('SMS send error: ' + smsError.toString());
    }
    
    Logger.log('Follow-up sent for doc ' + docId + ', SMS: ' + smsSent);
    return { ok: true, sms_sent: smsSent };
    
  } catch (error) {
    Logger.log('sendFollowUp error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Format phone number for Twilio (E.164 format)
 */
function formatPhoneForTwilio(phone) {
  if (!phone) return '';
  let digits = String(phone).replace(/\D/g, '');
  if (digits.length === 10) {
    digits = '1' + digits;
  }
  return '+' + digits;
}

/**
 * Log an outbound or inbound message
 */
function logMessage(msgData) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const sheet = ss.getSheetByName('Messages');
    if (!sheet) return;
    
    const messageId = 'MSG-' + Date.now();
    const timestamp = new Date().toISOString();
    
    sheet.appendRow([
      messageId,
      timestamp,
      msgData.direction || 'outbound',
      msgData.channel || 'sms',
      msgData.customer_phone || '',
      msgData.customer_email || '',
      msgData.customer_name || '',
      msgData.submission_id || '',
      msgData.quote_id || '',
      msgData.invoice_id || '',
      msgData.message_body || '',
      msgData.message_sid || '',
      msgData.status || 'sent',
      'FALSE',
      'FALSE'
    ]);
  } catch (e) {
    Logger.log('logMessage error: ' + e.toString());
  }
}

function testSendFollowUp() {
  // Use a real doc_id from your Documents sheet
  const testDocId = 1011; // Change this to an actual doc_id
  
  const options = {
    templateKey: 'CHECKING_IN',
    incentive: {
      percent: 10,
      expiresAt: '2026-01-27',
      expiryDays: 7
    }
  };
  
  const result = sendFollowUp(testDocId, options);
  Logger.log('Result: ' + JSON.stringify(result));
}

function testGetWebAppUrl() {
  Logger.log('CONFIG.webAppUrl: ' + CONFIG.webAppUrl);
  Logger.log('getWebAppUrl(): ' + getWebAppUrl());
}

function testFollowUpUpdate() {
  const docId = 1011; // Use your test doc
  
  // Simulate what sendFollowUp should do
  const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
  const sheet = ss.getSheetByName('Documents');
  const data = sheet.getDataRange().getValues();
  const headers = data[0];
  
  // Log current values
  const colMap = {};
  headers.forEach((h, i) => colMap[h] = i);
  
  for (let i = 1; i < data.length; i++) {
    if (data[i][colMap['doc_id']] == docId) {
      Logger.log('Current discount_percent: ' + data[i][colMap['discount_percent']]);
      Logger.log('Current discount_amount: ' + data[i][colMap['discount_amount']]);
      Logger.log('Current discount_note: ' + data[i][colMap['discount_note']]);
      Logger.log('Current deposit_required: ' + data[i][colMap['deposit_required']]);
      Logger.log('Current total: ' + data[i][colMap['total']]);
      break;
    }
  }
}

/**
 * Generate production tasks for an invoice based on line item categories
 * Called when invoice is paid OR when "Move to Production" button is clicked
 */
function generateProductionTasks(invoiceId) {
  try {
    Logger.log('generateProductionTasks called for invoice: ' + invoiceId);
    
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const specSS = SpreadsheetApp.openById(CONFIG.specSheetId);
    
    // Get the invoice
    const docsSheet = ss.getSheetByName('Documents');
    const docsData = docsSheet.getDataRange().getValues();
    const docsHeaders = docsData[0];
    
    const docColMap = {};
    docsHeaders.forEach((h, i) => docColMap[h] = i);
    
    let invoiceRow = -1;
    let invoice = null;
    for (let i = 1; i < docsData.length; i++) {
      if (String(docsData[i][docColMap['doc_id']]) === String(invoiceId)) {
        invoiceRow = i + 1;
        invoice = {};
        docsHeaders.forEach((h, idx) => invoice[h] = docsData[i][idx]);
        break;
      }
    }
    
    if (!invoice) {
      return { ok: false, error: 'Invoice not found: ' + invoiceId };
    }
    
    if (invoice.in_production === true || invoice.in_production === 'TRUE') {
      Logger.log('Invoice already in production, skipping task generation');
      return { ok: true, message: 'Already in production', tasks_created: 0 };
    }
    
    // Get line items for this invoice
    const lineItemsSheet = ss.getSheetByName('DocumentLineItems');
    const lineItemsData = lineItemsSheet.getDataRange().getValues();
    const lineItemsHeaders = lineItemsData[0];
    
    const lineColMap = {};
    lineItemsHeaders.forEach((h, i) => lineColMap[h] = i);
    
    const lineItems = [];
    for (let i = 1; i < lineItemsData.length; i++) {
      if (String(lineItemsData[i][lineColMap['doc_id']]) === String(invoiceId)) {
        const item = {};
        lineItemsHeaders.forEach((h, idx) => item[h] = lineItemsData[i][idx]);
        lineItems.push(item);
      }
    }
    
    if (lineItems.length === 0) {
      Logger.log('No line items found for invoice');
      return { ok: false, error: 'No line items found for invoice' };
    }
    
    // Get LineItemTypes for workflow lookup
    const lineItemTypesSheet = specSS.getSheetByName('LineItemTypes');
    const lineItemTypesData = lineItemTypesSheet ? lineItemTypesSheet.getDataRange().getValues() : [];
    const lineItemTypesMap = {};
    if (lineItemTypesData.length > 1) {
      const litHeaders = lineItemTypesData[0];
      const litTypeKeyCol = litHeaders.indexOf('type_key');
      const litWorkflowCol = litHeaders.indexOf('workflow_key');
      const litCategoryCol = litHeaders.indexOf('category_key');
      for (let i = 1; i < lineItemTypesData.length; i++) {
        const typeKey = lineItemTypesData[i][litTypeKeyCol];
        if (typeKey) {
          lineItemTypesMap[typeKey] = {
            workflow_key: lineItemTypesData[i][litWorkflowCol],
            category_key: lineItemTypesData[i][litCategoryCol]
          };
        }
      }
    }
    
    // Get TemplateTasks for task definitions
    const templateTasksSheet = specSS.getSheetByName('TemplateTasks');
    const templateTasksData = templateTasksSheet.getDataRange().getValues();
    const ttHeaders = templateTasksData[0];
    
    const ttColMap = {};
    ttHeaders.forEach((h, i) => ttColMap[h] = i);
    
    const allTasks = [];
    for (let i = 1; i < templateTasksData.length; i++) {
      const row = templateTasksData[i];
      if (row[ttColMap['active']] === true || row[ttColMap['active']] === 'TRUE') {
        const task = {};
        ttHeaders.forEach((h, idx) => task[h] = row[idx]);
        allTasks.push(task);
      }
    }
    
    // Get Categories for fallback workflow lookup
    const categoriesSheet = specSS.getSheetByName('Categories');
    const categoriesData = categoriesSheet.getDataRange().getValues();
    const catHeaders = categoriesData[0];
    const catColMap = {};
    catHeaders.forEach((h, i) => catColMap[h] = i);
    
    const categoryWorkflowMap = {};
    for (let i = 1; i < categoriesData.length; i++) {
      const catKey = categoriesData[i][catColMap['category_key']];
      // Default workflow is category_key + '_WORKFLOW' or just category_key
      categoryWorkflowMap[catKey] = catKey + '_WORKFLOW';
    }
    
    // Get or create ProductionTasks sheet with updated columns
    let prodTasksSheet = ss.getSheetByName('ProductionTasks');
    if (!prodTasksSheet) {
      prodTasksSheet = ss.insertSheet('ProductionTasks');
      prodTasksSheet.appendRow(['task_id', 'invoice_id', 'line_id', 'workflow_key', 'category', 'step_order', 'task_name', 'status', 'completed_at', 'completed_by', 'notes']);
    }
    
    // Get existing headers to handle both old and new schema
    const prodHeaders = prodTasksSheet.getRange(1, 1, 1, prodTasksSheet.getLastColumn()).getValues()[0];
    const hasWorkflowKeyCol = prodHeaders.indexOf('workflow_key') > -1;
    
    let tasksCreated = 0;
    
    // Process each line item
    lineItems.forEach(lineItem => {
      const lineType = lineItem.line_type;
      const category = lineItem.category;
      let workflowKey = null;
      
      // Determine workflow: line_type > category fallback
      if (lineType && lineItemTypesMap[lineType]) {
        workflowKey = lineItemTypesMap[lineType].workflow_key;
        Logger.log('Line ' + lineItem.line_id + ': Using workflow from line_type: ' + workflowKey);
      } else if (category) {
        // Fallback: try category-based workflow
        workflowKey = category + '_WORKFLOW';
        // Also try just the category key as template_key
        const directMatch = allTasks.some(t => t.template_key === category);
        if (directMatch) {
          workflowKey = category;
        }
        Logger.log('Line ' + lineItem.line_id + ': Using fallback workflow from category: ' + workflowKey);
      }
      
      if (!workflowKey) {
        Logger.log('Line ' + lineItem.line_id + ': No workflow found, skipping');
        return;
      }
      
      // Get tasks for this workflow
      const workflowTasks = allTasks
        .filter(t => t.template_key === workflowKey)
        .sort((a, b) => (a.sort_order || 0) - (b.sort_order || 0));
      
      if (workflowTasks.length === 0) {
        Logger.log('No tasks found for workflow: ' + workflowKey);
        return;
      }
      
      // Create tasks for this line item
      workflowTasks.forEach(task => {
        const taskId = 'PT-' + invoiceId + '-' + (lineItem.line_id || 'X') + '-' + task.sort_order;
        
        let taskRow;
        if (hasWorkflowKeyCol) {
          taskRow = [
            taskId,
            invoiceId,
            lineItem.line_id || '',
            workflowKey,
            category || '',
            task.sort_order || 0,
            task.label || '',
            'PENDING',
            '',
            '',
            ''
          ];
        } else {
          // Old schema without workflow_key column
          taskRow = [
            taskId,
            invoiceId,
            lineItem.line_id || '',
            category || '',
            task.sort_order || 0,
            task.label || '',
            'PENDING',
            '',
            '',
            ''
          ];
        }
        
        prodTasksSheet.appendRow(taskRow);
        tasksCreated++;
      });
      
      Logger.log('Created ' + workflowTasks.length + ' tasks for line ' + lineItem.line_id);
    });
    
    // Mark invoice as in_production
    if (docColMap['in_production'] !== undefined) {
      docsSheet.getRange(invoiceRow, docColMap['in_production'] + 1).setValue(true);
    }
    
    if (docColMap['bucket'] !== undefined) {
      docsSheet.getRange(invoiceRow, docColMap['bucket'] + 1).setValue('IN_PRODUCTION');
    }
    
    Logger.log('Production tasks created: ' + tasksCreated);
    
    return { 
      ok: true, 
      message: 'Production tasks generated', 
      tasks_created: tasksCreated,
      invoice_id: invoiceId
    };
    
  } catch (error) {
    Logger.log('generateProductionTasks error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

function testGenerateProductionTasks() {
  const result = generateProductionTasks(1002);
  Logger.log('Result: ' + JSON.stringify(result));
}

function testSheetNames() {
  const specSS = SpreadsheetApp.openById('1RvRIcNDsYGvx2to302lzDs3nmFQXHETYNZzMWoyFnhE');
  const sheets = specSS.getSheets();
  sheets.forEach(s => Logger.log('Sheet: "' + s.getName() + '"'));
}

/**
 * ============================================================================
 * FWG CATEGORY RESTRUCTURE - Schema Setup
 * Run this function ONCE to set up the new schema
 * ============================================================================
 */

/**
 * MAIN SETUP FUNCTION - Run this to create all new sheets and columns
 */
function setupCategoryRestructure() {
  const specSheetId = CONFIG.specSheetId;
  const opsSheetId = CONFIG.opsSheetId;
  
  Logger.log('=== Starting Category Restructure Setup ===');
  
  // Step 1: Update Categories sheet
  updateCategoriesSheet(specSheetId);
  
  // Step 2: Create LineItemTypes sheet
  createLineItemTypesSheet(specSheetId);
  
  // Step 3: Update DocumentLineItems sheet
  updateDocumentLineItemsSheet(opsSheetId);
  
  // Step 4: Update ProductionTasks sheet
  updateProductionTasksSheet(opsSheetId);
  
  // Step 5: Update Packages sheet
  updatePackagesSheet(specSheetId);
  
  Logger.log('=== Category Restructure Setup Complete ===');
  Logger.log('Next steps:');
  Logger.log('1. Populate Categories with parent_category values (AUTOMOTIVE, SIGNAGE, APPAREL)');
  Logger.log('2. Populate LineItemTypes with your type variants');
  Logger.log('3. Update WorkflowTemplates to link to types instead of categories');
}

/**
 * Step 1: Add parent_category and has_types columns to Categories
 */
function updateCategoriesSheet(specSheetId) {
  Logger.log('Step 1: Updating Categories sheet...');
  
  const ss = SpreadsheetApp.openById(specSheetId);
  const sheet = ss.getSheetByName('Categories');
  
  if (!sheet) {
    Logger.log('ERROR: Categories sheet not found');
    return;
  }
  
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  
  // Check if parent_category already exists
  if (headers.indexOf('parent_category') === -1) {
    // Add parent_category after category_key (column B position, insert at column 2)
    const insertCol = 2;
    sheet.insertColumnAfter(1);
    sheet.getRange(1, insertCol).setValue('parent_category');
    Logger.log('  Added parent_category column');
  } else {
    Logger.log('  parent_category column already exists');
  }
  
  // Refresh headers after potential insert
  const updatedHeaders = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  
  // Check if has_types already exists
  if (updatedHeaders.indexOf('has_types') === -1) {
    // Add has_types at the end before notes
    const notesCol = updatedHeaders.indexOf('notes');
    if (notesCol > -1) {
      sheet.insertColumnBefore(notesCol + 1);
      sheet.getRange(1, notesCol + 1).setValue('has_types');
    } else {
      // Add at end
      sheet.getRange(1, sheet.getLastColumn() + 1).setValue('has_types');
    }
    Logger.log('  Added has_types column');
  } else {
    Logger.log('  has_types column already exists');
  }
  
  Logger.log('Step 1 Complete: Categories sheet updated');
}

/**
 * Step 2: Create LineItemTypes sheet
 */
function createLineItemTypesSheet(specSheetId) {
  Logger.log('Step 2: Creating LineItemTypes sheet...');
  
  const ss = SpreadsheetApp.openById(specSheetId);
  
  // Check if sheet already exists
  let sheet = ss.getSheetByName('LineItemTypes');
  if (sheet) {
    Logger.log('  LineItemTypes sheet already exists - skipping creation');
    return;
  }
  
  // Create new sheet
  sheet = ss.insertSheet('LineItemTypes');
  
  // Define headers
  const headers = [
    'type_key',           // PRIMARY KEY - e.g., CONTOUR_CUT, KISS_CUT
    'category_key',       // FK to Categories - e.g., STICKERS
    'parent_category',    // Denormalized for easy filtering - AUTOMOTIVE, SIGNAGE, APPAREL
    'label',              // Display name - "Contour Cut"
    'description',        // Help text for selection
    'workflow_key',       // FK to WorkflowTemplates - determines task list
    'line_template',      // Override LineItemTemplate if different from category
    'default_rate',       // Default pricing rate
    'estimated_mins',     // Estimated production time
    'sort_order',         // Display order in dropdown
    'active',             // TRUE/FALSE
    'notes'               // Internal notes
  ];
  
  // Set headers
  sheet.getRange(1, 1, 1, headers.length).setValues([headers]);
  
  // Format header row
  const headerRange = sheet.getRange(1, 1, 1, headers.length);
  headerRange.setFontWeight('bold');
  headerRange.setBackground('#f3f4f6');
  
  // Set column widths
  sheet.setColumnWidth(1, 150);  // type_key
  sheet.setColumnWidth(2, 120);  // category_key
  sheet.setColumnWidth(3, 120);  // parent_category
  sheet.setColumnWidth(4, 150);  // label
  sheet.setColumnWidth(5, 250);  // description
  sheet.setColumnWidth(6, 180);  // workflow_key
  sheet.setColumnWidth(7, 120);  // line_template
  sheet.setColumnWidth(8, 100);  // default_rate
  sheet.setColumnWidth(9, 100);  // estimated_mins
  sheet.setColumnWidth(10, 80);  // sort_order
  sheet.setColumnWidth(11, 60);  // active
  sheet.setColumnWidth(12, 200); // notes
  
  // Freeze header row
  sheet.setFrozenRows(1);
  
  // Add some example data to illustrate the structure
  const exampleData = [
    ['CONTOUR_CUT', 'STICKERS', 'SIGNAGE', 'Contour Cut', 'Print & cut on same machine, pluck by hand', 'STICKER_CONTOUR_WORKFLOW', '', '', 45, 1, 'TRUE', 'Most common sticker type'],
    ['KISS_CUT', 'STICKERS', 'SIGNAGE', 'Kiss Cut', 'Print then cut on plotter, weed and strip', 'STICKER_KISS_WORKFLOW', '', '', 60, 2, 'TRUE', 'Sheet stickers'],
    ['DIE_CUT', 'STICKERS', 'SIGNAGE', 'Die Cut', 'Custom die cut stickers', 'STICKER_DIE_WORKFLOW', '', '', 90, 3, 'TRUE', 'Premium custom shapes'],
    ['ROLL_LABELS', 'LABELS', 'SIGNAGE', 'Roll Labels', 'High volume roll labels', 'LABEL_ROLL_WORKFLOW', '', '', 30, 1, 'TRUE', 'Bulk roll format'],
    ['SHEET_LABELS', 'LABELS', 'SIGNAGE', 'Sheet Labels', 'Sheet format labels', 'LABEL_SHEET_WORKFLOW', '', '', 45, 2, 'TRUE', 'Sheet format'],
    ['PPF_FULL_FRONT', 'PPF', 'AUTOMOTIVE', 'Full Front', 'Complete front end coverage', 'PPF_WORKFLOW', '', '', 180, 1, 'TRUE', ''],
    ['PPF_PARTIAL', 'PPF', 'AUTOMOTIVE', 'Partial Coverage', 'Selected panels only', 'PPF_WORKFLOW', '', '', 120, 2, 'TRUE', ''],
    ['PPF_TRACK_PACK', 'PPF', 'AUTOMOTIVE', 'Track Pack', 'High impact areas', 'PPF_WORKFLOW', '', '', 90, 3, 'TRUE', ''],
    ['PPF_FULL_BODY', 'PPF', 'AUTOMOTIVE', 'Full Body', 'Complete vehicle coverage', 'PPF_FULL_WORKFLOW', '', '', 480, 4, 'TRUE', ''],
    ['COMMERCIAL_FULL', 'FULL_WRAP', 'AUTOMOTIVE', 'Commercial Full Wrap', 'Full vehicle wrap for business branding', 'FULL_WRAP_WORKFLOW', '', '', 360, 1, 'TRUE', ''],
    ['COLOR_CHANGE_FULL', 'COLOR_CHANGE', 'AUTOMOTIVE', 'Full Color Change', 'Complete vehicle color change', 'COLOR_CHANGE_WORKFLOW', '', '', 480, 1, 'TRUE', ''],
  ];
  
  if (exampleData.length > 0) {
    sheet.getRange(2, 1, exampleData.length, exampleData[0].length).setValues(exampleData);
  }
  
  Logger.log('Step 2 Complete: LineItemTypes sheet created with example data');
}

/**
 * Step 3: Add line_type column to DocumentLineItems
 */
function updateDocumentLineItemsSheet(opsSheetId) {
  Logger.log('Step 3: Updating DocumentLineItems sheet...');
  
  const ss = SpreadsheetApp.openById(opsSheetId);
  const sheet = ss.getSheetByName('DocumentLineItems');
  
  if (!sheet) {
    Logger.log('ERROR: DocumentLineItems sheet not found');
    return;
  }
  
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  
  // Check if line_type already exists
  if (headers.indexOf('line_type') === -1) {
    // Add after category column
    const categoryCol = headers.indexOf('category');
    if (categoryCol > -1) {
      sheet.insertColumnAfter(categoryCol + 1);
      sheet.getRange(1, categoryCol + 2).setValue('line_type');
    } else {
      // Add at end
      sheet.getRange(1, sheet.getLastColumn() + 1).setValue('line_type');
    }
    Logger.log('  Added line_type column');
  } else {
    Logger.log('  line_type column already exists');
  }
  
  // Check if package_key already exists
  const updatedHeaders = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  if (updatedHeaders.indexOf('package_key') === -1) {
    // Add after line_type
    const lineTypeCol = updatedHeaders.indexOf('line_type');
    if (lineTypeCol > -1) {
      sheet.insertColumnAfter(lineTypeCol + 1);
      sheet.getRange(1, lineTypeCol + 2).setValue('package_key');
    } else {
      sheet.getRange(1, sheet.getLastColumn() + 1).setValue('package_key');
    }
    Logger.log('  Added package_key column');
  } else {
    Logger.log('  package_key column already exists');
  }
  
  Logger.log('Step 3 Complete: DocumentLineItems sheet updated');
}

/**
 * Step 4: Add line_id column to ProductionTasks (if using Tasks sheet for production)
 */
function updateProductionTasksSheet(opsSheetId) {
  Logger.log('Step 4: Updating ProductionTasks sheet...');
  
  const ss = SpreadsheetApp.openById(opsSheetId);
  
  // Check for ProductionTasks sheet first, fall back to Tasks
  let sheet = ss.getSheetByName('ProductionTasks');
  if (!sheet) {
    sheet = ss.getSheetByName('Tasks');
  }
  
  if (!sheet) {
    Logger.log('ERROR: ProductionTasks/Tasks sheet not found');
    return;
  }
  
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  
  // Check if line_id already exists
  if (headers.indexOf('line_id') === -1) {
    // Add after invoice_id column
    const invoiceIdCol = headers.indexOf('invoice_id');
    if (invoiceIdCol > -1) {
      sheet.insertColumnAfter(invoiceIdCol + 1);
      sheet.getRange(1, invoiceIdCol + 2).setValue('line_id');
    } else {
      // Add at position 3
      sheet.insertColumnAfter(2);
      sheet.getRange(1, 3).setValue('line_id');
    }
    Logger.log('  Added line_id column');
  } else {
    Logger.log('  line_id column already exists');
  }
  
  // Check if workflow_key already exists
  const updatedHeaders = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  if (updatedHeaders.indexOf('workflow_key') === -1) {
    // Add after line_id
    const lineIdCol = updatedHeaders.indexOf('line_id');
    if (lineIdCol > -1) {
      sheet.insertColumnAfter(lineIdCol + 1);
      sheet.getRange(1, lineIdCol + 2).setValue('workflow_key');
    } else {
      sheet.getRange(1, sheet.getLastColumn() + 1).setValue('workflow_key');
    }
    Logger.log('  Added workflow_key column');
  } else {
    Logger.log('  workflow_key column already exists');
  }
  
  Logger.log('Step 4 Complete: ProductionTasks sheet updated');
}

/**
 * Step 5: Add type_key column to Packages
 */
function updatePackagesSheet(specSheetId) {
  Logger.log('Step 5: Updating Packages sheet...');
  
  const ss = SpreadsheetApp.openById(specSheetId);
  const sheet = ss.getSheetByName('Packages');
  
  if (!sheet) {
    Logger.log('ERROR: Packages sheet not found');
    return;
  }
  
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  
  // Check if type_key already exists
  if (headers.indexOf('type_key') === -1) {
    // Add after category_key column
    const categoryCol = headers.indexOf('category_key');
    if (categoryCol > -1) {
      sheet.insertColumnAfter(categoryCol + 1);
      sheet.getRange(1, categoryCol + 2).setValue('type_key');
    } else {
      // Add at position 3
      sheet.insertColumnAfter(2);
      sheet.getRange(1, 3).setValue('type_key');
    }
    Logger.log('  Added type_key column');
  } else {
    Logger.log('  type_key column already exists');
  }
  
  // Check for promo columns
  const updatedHeaders = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  
  if (updatedHeaders.indexOf('promo_price') === -1) {
    sheet.getRange(1, sheet.getLastColumn() + 1).setValue('promo_price');
    Logger.log('  Added promo_price column');
  }
  
  const finalHeaders = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  if (finalHeaders.indexOf('promo_expires') === -1) {
    sheet.getRange(1, sheet.getLastColumn() + 1).setValue('promo_expires');
    Logger.log('  Added promo_expires column');
  }
  
  const finalHeaders2 = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  if (finalHeaders2.indexOf('website_visible') === -1) {
    sheet.getRange(1, sheet.getLastColumn() + 1).setValue('website_visible');
    Logger.log('  Added website_visible column');
  }
  
  Logger.log('Step 5 Complete: Packages sheet updated');
}

/**
 * HELPER: Populate parent_category values in Categories sheet
 * Run this AFTER setupCategoryRestructure() and AFTER you've reviewed the mappings
 */
function populateCategoryParents() {
  const specSheetId = CONFIG.specSheetId;
  const ss = SpreadsheetApp.openById(specSheetId);
  const sheet = ss.getSheetByName('Categories');
  
  if (!sheet) {
    Logger.log('ERROR: Categories sheet not found');
    return;
  }
  
  const data = sheet.getDataRange().getValues();
  const headers = data[0];
  const categoryKeyCol = headers.indexOf('category_key');
  const parentCategoryCol = headers.indexOf('parent_category');
  
  if (parentCategoryCol === -1) {
    Logger.log('ERROR: parent_category column not found. Run setupCategoryRestructure() first.');
    return;
  }
  
  // Define parent mappings based on your three sheets
  const parentMappings = {
    // AUTOMOTIVE
    'PPF': 'AUTOMOTIVE',
    'FULL_WRAP': 'AUTOMOTIVE',
    'PARTIAL_WRAP': 'AUTOMOTIVE',
    'COLOR_CHANGE': 'AUTOMOTIVE',
    'VINYL_LETTERING': 'AUTOMOTIVE',
    'VINYL_GRAPHICS': 'AUTOMOTIVE',
    'VINYL_DECALS': 'AUTOMOTIVE',
    'VINYL_FOX': 'AUTOMOTIVE',
    'VAN_INSERTS': 'AUTOMOTIVE',
    'WINDOW_PERF': 'AUTOMOTIVE',
    'AUTO_STYLING': 'AUTOMOTIVE',
    'CHROME_DELETE': 'AUTOMOTIVE',
    
    // SIGNAGE
    'SIGNAGE': 'SIGNAGE',
    'STICKERS': 'SIGNAGE',
    'LABELS': 'SIGNAGE',
    'LABELS_OH': 'SIGNAGE',
    'LABELS_OD': 'SIGNAGE',
    'BANNERS': 'SIGNAGE',
    'BANNER_STAND': 'SIGNAGE',
    'YARD_SIGNS': 'SIGNAGE',
    'SIGN_BOARDS': 'SIGNAGE',
    'MAGNETS': 'SIGNAGE',
    
    // APPAREL
    'APPAREL': 'APPAREL',
    'DTF_TRANSFER': 'APPAREL',
    'EMBROIDERY': 'APPAREL',
    
    // OTHER
    'DESIGN_FEE': 'OTHER',
    'OTHER': 'OTHER',
    'COFFEE_MACHINE': 'OTHER'
  };
  
  let updatedCount = 0;
  
  for (let i = 1; i < data.length; i++) {
    const categoryKey = data[i][categoryKeyCol];
    if (categoryKey && parentMappings[categoryKey]) {
      sheet.getRange(i + 1, parentCategoryCol + 1).setValue(parentMappings[categoryKey]);
      updatedCount++;
    }
  }
  
  Logger.log('Updated ' + updatedCount + ' categories with parent_category values');
}

/**
 * Merge all parent category sheets into main Categories sheet
 * Run this AFTER setupCategoryRestructure()
 */
function mergeCategorySheets() {
  const ss = SpreadsheetApp.openById(CONFIG.specSheetId);
  const mainSheet = ss.getSheetByName('Categories');
  
  if (!mainSheet) {
    Logger.log('ERROR: Categories sheet not found');
    return;
  }
  
  // Get main sheet headers
  const mainHeaders = mainSheet.getRange(1, 1, 1, mainSheet.getLastColumn()).getValues()[0];
  const mainCategoryKeyCol = mainHeaders.indexOf('category_key');
  const mainParentCategoryCol = mainHeaders.indexOf('parent_category');
  const mainHasTypesCol = mainHeaders.indexOf('has_types');
  
  if (mainParentCategoryCol === -1) {
    Logger.log('ERROR: parent_category column not found. Run setupCategoryRestructure() first.');
    return;
  }
  
  // Get existing category keys to avoid duplicates
  const mainData = mainSheet.getDataRange().getValues();
  const existingKeys = new Set();
  for (let i = 1; i < mainData.length; i++) {
    if (mainData[i][mainCategoryKeyCol]) {
      existingKeys.add(mainData[i][mainCategoryKeyCol]);
    }
  }
  
  Logger.log('Existing categories: ' + existingKeys.size);
  
  // Define source sheets and their parent category
  const sourceSheets = [
    { name: 'AutomotiveCategories', parent: 'AUTOMOTIVE' },
    { name: 'SignageCategories', parent: 'SIGNAGE' },
    { name: 'ApparelCategories', parent: 'APPAREL' }
  ];
  
  // Categories that should have has_types = TRUE
  const categoriesWithTypes = [
    'STICKERS', 'LABELS', 'LABELS_OH', 'LABELS_OD', 'PPF', 
    'FULL_WRAP', 'PARTIAL_WRAP', 'COLOR_CHANGE', 'EMBROIDERY',
    'APPAREL', 'DTF_TRANSFER', 'SIGNAGE', 'BANNERS'
  ];
  
  let addedCount = 0;
  let updatedCount = 0;
  
  sourceSheets.forEach(source => {
    const sourceSheet = ss.getSheetByName(source.name);
    if (!sourceSheet) {
      Logger.log('WARNING: Sheet not found: ' + source.name);
      return;
    }
    
    const sourceData = sourceSheet.getDataRange().getValues();
    const sourceHeaders = sourceData[0];
    
    // Map source columns
    const srcCategoryKeyCol = sourceHeaders.indexOf('category_key');
    const srcLabelCol = sourceHeaders.indexOf('label');
    const srcCalendarColorCol = sourceHeaders.indexOf('calendar_color');
    const srcLineTemplateCol = sourceHeaders.indexOf('line_template');
    const srcUnitLabelCol = sourceHeaders.indexOf('unit_label');
    const srcHasPackagesCol = sourceHeaders.indexOf('has_packages');
    const srcIsVehicleBasedCol = sourceHeaders.indexOf('is_vehicle_based');
    const srcDefaultRateCol = sourceHeaders.indexOf('default_rate');
    const srcSortOrderCol = sourceHeaders.indexOf('sort_order');
    const srcActiveCol = sourceHeaders.indexOf('active');
    const srcNotesCol = sourceHeaders.indexOf('notes');
    
    for (let i = 1; i < sourceData.length; i++) {
      const categoryKey = sourceData[i][srcCategoryKeyCol];
      
      // Skip empty rows or header-like rows (like "Commercial" or "Automotive Styling" section labels)
      if (!categoryKey || categoryKey === '' || !categoryKey.match(/^[A-Z_]+$/)) {
        continue;
      }
      
      const hasTypes = categoriesWithTypes.includes(categoryKey) ? 'TRUE' : 'FALSE';
      
      if (existingKeys.has(categoryKey)) {
        // Update existing row with parent_category
        for (let j = 1; j < mainData.length; j++) {
          if (mainData[j][mainCategoryKeyCol] === categoryKey) {
            mainSheet.getRange(j + 1, mainParentCategoryCol + 1).setValue(source.parent);
            if (mainHasTypesCol > -1) {
              mainSheet.getRange(j + 1, mainHasTypesCol + 1).setValue(hasTypes);
            }
            updatedCount++;
            break;
          }
        }
      } else {
        // Build new row matching main sheet column order
        const newRow = [];
        mainHeaders.forEach((header, colIndex) => {
          switch(header) {
            case 'category_key':
              newRow.push(categoryKey);
              break;
            case 'parent_category':
              newRow.push(source.parent);
              break;
            case 'label':
              newRow.push(srcLabelCol > -1 ? sourceData[i][srcLabelCol] : '');
              break;
            case 'calendar_color':
              newRow.push(srcCalendarColorCol > -1 ? sourceData[i][srcCalendarColorCol] : '#94A3B8');
              break;
            case 'line_template':
              newRow.push(srcLineTemplateCol > -1 ? sourceData[i][srcLineTemplateCol] : 'DEFAULT');
              break;
            case 'unit_label':
              newRow.push(srcUnitLabelCol > -1 ? sourceData[i][srcUnitLabelCol] : 'Qty');
              break;
            case 'has_packages':
              newRow.push(srcHasPackagesCol > -1 ? sourceData[i][srcHasPackagesCol] : 'FALSE');
              break;
            case 'is_vehicle_based':
              newRow.push(srcIsVehicleBasedCol > -1 ? sourceData[i][srcIsVehicleBasedCol] : 'FALSE');
              break;
            case 'default_rate':
              newRow.push(srcDefaultRateCol > -1 ? sourceData[i][srcDefaultRateCol] : 0);
              break;
            case 'sort_order':
              newRow.push(srcSortOrderCol > -1 ? sourceData[i][srcSortOrderCol] : 99);
              break;
            case 'active':
              newRow.push(srcActiveCol > -1 ? sourceData[i][srcActiveCol] : 'TRUE');
              break;
            case 'has_types':
              newRow.push(hasTypes);
              break;
            case 'notes':
              newRow.push(srcNotesCol > -1 ? sourceData[i][srcNotesCol] : '');
              break;
            default:
              newRow.push('');
          }
        });
        
        // Append new row
        mainSheet.appendRow(newRow);
        existingKeys.add(categoryKey);
        addedCount++;
        Logger.log('Added: ' + categoryKey + ' (' + source.parent + ')');
      }
    }
  });
  
  Logger.log('=== Merge Complete ===');
  Logger.log('Added: ' + addedCount + ' new categories');
  Logger.log('Updated: ' + updatedCount + ' existing categories');
}

/**
 * Create DocumentFees sheet for universal fees (Design, Shipping, Rush, etc.)
 * Run this to add the fees infrastructure
 */
function createDocumentFeesSheet() {
  const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
  
  // Check if sheet already exists
  let sheet = ss.getSheetByName('DocumentFees');
  if (sheet) {
    Logger.log('DocumentFees sheet already exists - skipping creation');
    return;
  }
  
  // Create new sheet
  sheet = ss.insertSheet('DocumentFees');
  
  // Define headers
  const headers = [
    'fee_id',           // PRIMARY KEY - e.g., FEE-1045-1
    'doc_id',           // FK to Documents
    'fee_type',         // DESIGN, SHIPPING, DELIVERY, RUSH, SETUP, OTHER
    'description',      // "Logo Design", "Ground Shipping", etc.
    'amount',           // Fee amount
    'notes',            // Internal notes
    'created_at'        // Timestamp
  ];
  
  // Set headers
  sheet.getRange(1, 1, 1, headers.length).setValues([headers]);
  
  // Format header row
  const headerRange = sheet.getRange(1, 1, 1, headers.length);
  headerRange.setFontWeight('bold');
  headerRange.setBackground('#f3f4f6');
  
  // Set column widths
  sheet.setColumnWidth(1, 120);  // fee_id
  sheet.setColumnWidth(2, 80);   // doc_id
  sheet.setColumnWidth(3, 100);  // fee_type
  sheet.setColumnWidth(4, 250);  // description
  sheet.setColumnWidth(5, 100);  // amount
  sheet.setColumnWidth(6, 200);  // notes
  sheet.setColumnWidth(7, 150);  // created_at
  
  // Freeze header row
  sheet.setFrozenRows(1);
  
  Logger.log('DocumentFees sheet created successfully');
  
  // Now create FeeTypes in spec sheet
  createFeeTypesSheet();
}

/**
 * Create FeeTypes sheet in Spec spreadsheet for fee type configuration
 */
function createFeeTypesSheet() {
  const ss = SpreadsheetApp.openById(CONFIG.specSheetId);
  
  // Check if sheet already exists
  let sheet = ss.getSheetByName('FeeTypes');
  if (sheet) {
    Logger.log('FeeTypes sheet already exists - skipping creation');
    return;
  }
  
  // Create new sheet
  sheet = ss.insertSheet('FeeTypes');
  
  // Define headers
  const headers = [
    'fee_type_key',     // PRIMARY KEY - DESIGN, SHIPPING, etc.
    'label',            // Display name
    'description',      // Help text
    'default_amount',   // Default/suggested amount
    'is_taxable',       // TRUE/FALSE - should tax apply?
    'sort_order',       // Display order
    'active',           // TRUE/FALSE
    'notes'             // Internal notes
  ];
  
  // Set headers
  sheet.getRange(1, 1, 1, headers.length).setValues([headers]);
  
  // Format header row
  const headerRange = sheet.getRange(1, 1, 1, headers.length);
  headerRange.setFontWeight('bold');
  headerRange.setBackground('#f3f4f6');
  
  // Add default fee types
  const defaultFeeTypes = [
    ['DESIGN', 'Design Fee', 'Custom design and artwork creation', 150, 'TRUE', 1, 'TRUE', ''],
    ['SHIPPING', 'Shipping', 'Shipping and handling', 0, 'FALSE', 2, 'TRUE', 'Amount varies by destination'],
    ['DELIVERY', 'Local Delivery', 'Local delivery within service area', 50, 'FALSE', 3, 'TRUE', ''],
    ['RUSH', 'Rush Fee', 'Expedited production timeline', 0, 'TRUE', 4, 'TRUE', 'Typically 25-50% of order'],
    ['SETUP', 'Setup Fee', 'One-time setup for production', 0, 'TRUE', 5, 'TRUE', ''],
    ['REVISION', 'Revision Fee', 'Additional design revisions beyond included', 75, 'TRUE', 6, 'TRUE', ''],
    ['OTHER', 'Other Fee', 'Miscellaneous fees', 0, 'TRUE', 99, 'TRUE', '']
  ];
  
  sheet.getRange(2, 1, defaultFeeTypes.length, defaultFeeTypes[0].length).setValues(defaultFeeTypes);
  
  // Set column widths
  sheet.setColumnWidth(1, 120);  // fee_type_key
  sheet.setColumnWidth(2, 150);  // label
  sheet.setColumnWidth(3, 250);  // description
  sheet.setColumnWidth(4, 100);  // default_amount
  sheet.setColumnWidth(5, 80);   // is_taxable
  sheet.setColumnWidth(6, 80);   // sort_order
  sheet.setColumnWidth(7, 60);   // active
  sheet.setColumnWidth(8, 200);  // notes
  
  // Freeze header row
  sheet.setFrozenRows(1);
  
  Logger.log('FeeTypes sheet created with default fee types');
}

// ============================================================================
// CATEGORY RESTRUCTURE - Backend Functions
// ============================================================================

/**
 * Get all categories grouped by parent category
 */
function getCategoriesGrouped() {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.specSheetId);
    const sheet = ss.getSheetByName('Categories');
    
    if (!sheet) {
      return { ok: false, error: 'Categories sheet not found' };
    }
    
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    
    const categories = [];
    const grouped = {
      AUTOMOTIVE: [],
      SIGNAGE: [],
      APPAREL: [],
      OTHER: []
    };
    
    for (let i = 1; i < data.length; i++) {
      if (!data[i][0]) continue;
      
      const category = {};
      headers.forEach((header, col) => {
        category[header] = data[i][col];
      });
      
      if (category.active === true || category.active === 'TRUE') {
        categories.push(category);
        
        const parent = category.parent_category || 'OTHER';
        if (grouped[parent]) {
          grouped[parent].push(category);
        } else {
          grouped.OTHER.push(category);
        }
      }
    }
    
    Object.keys(grouped).forEach(key => {
      grouped[key].sort((a, b) => (a.sort_order || 99) - (b.sort_order || 99));
    });
    
    return { 
      ok: true, 
      categories: categories,
      grouped: grouped,
      parents: ['AUTOMOTIVE', 'SIGNAGE', 'APPAREL']
    };
    
  } catch (error) {
    Logger.log('getCategoriesGrouped error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Get line item types, optionally filtered by category
 */
function getLineItemTypes(categoryKey) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.specSheetId);
    const sheet = ss.getSheetByName('LineItemTypes');
    
    if (!sheet) {
      return { ok: false, error: 'LineItemTypes sheet not found' };
    }
    
    const data = sheet.getDataRange().getValues();
    if (data.length < 2) {
      return { ok: true, types: [] };
    }
    
    const headers = data[0];
    const types = [];
    
    for (let i = 1; i < data.length; i++) {
      if (!data[i][0]) continue;
      
      const type = {};
      headers.forEach((header, col) => {
        type[header] = data[i][col];
      });
      
      if (type.active !== true && type.active !== 'TRUE') continue;
      if (categoryKey && type.category_key !== categoryKey) continue;
      
      types.push(type);
    }
    
    types.sort((a, b) => (a.sort_order || 99) - (b.sort_order || 99));
    
    return { ok: true, types: types };
    
  } catch (error) {
    Logger.log('getLineItemTypes error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Get all fee types
 */
function getFeeTypes() {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.specSheetId);
    const sheet = ss.getSheetByName('FeeTypes');
    
    if (!sheet) {
      return { ok: false, error: 'FeeTypes sheet not found' };
    }
    
    const data = sheet.getDataRange().getValues();
    if (data.length < 2) {
      return { ok: true, feeTypes: [] };
    }
    
    const headers = data[0];
    const feeTypes = [];
    
    for (let i = 1; i < data.length; i++) {
      if (!data[i][0]) continue;
      
      const feeType = {};
      headers.forEach((header, col) => {
        feeType[header] = data[i][col];
      });
      
      if (feeType.active === true || feeType.active === 'TRUE') {
        feeTypes.push(feeType);
      }
    }
    
    feeTypes.sort((a, b) => (a.sort_order || 99) - (b.sort_order || 99));
    
    return { ok: true, feeTypes: feeTypes };
    
  } catch (error) {
    Logger.log('getFeeTypes error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Get fees for a document
 */
function getDocumentFees(docId) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const sheet = ss.getSheetByName('DocumentFees');
    
    if (!sheet) {
      return { ok: true, fees: [] };
    }
    
    const data = sheet.getDataRange().getValues();
    if (data.length < 2) {
      return { ok: true, fees: [] };
    }
    
    const headers = data[0];
    const docIdCol = headers.indexOf('doc_id');
    const fees = [];
    
    for (let i = 1; i < data.length; i++) {
      if (String(data[i][docIdCol]) !== String(docId)) continue;
      
      const fee = {};
      headers.forEach((header, col) => {
        fee[header] = data[i][col];
      });
      fees.push(fee);
    }
    
    return { ok: true, fees: sanitizeForJson(fees) };
    
  } catch (error) {
    Logger.log('getDocumentFees error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Add a fee to a document
 */
function addDocumentFee(docId, feeData) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const sheet = ss.getSheetByName('DocumentFees');
    
    if (!sheet) {
      return { ok: false, error: 'DocumentFees sheet not found' };
    }
    
    const feeId = 'FEE-' + docId + '-' + Date.now();
    const now = new Date().toISOString();
    
    const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    
    const newRow = headers.map(header => {
      switch(header) {
        case 'fee_id': return feeId;
        case 'doc_id': return docId;
        case 'fee_type': return feeData.fee_type || 'OTHER';
        case 'description': return feeData.description || '';
        case 'amount': return feeData.amount || 0;
        case 'notes': return feeData.notes || '';
        case 'created_at': return now;
        default: return '';
      }
    });
    
    sheet.appendRow(newRow);
    recalculateDocumentTotals(docId);
    
    return { 
      ok: true, 
      fee_id: feeId,
      fee: {
        fee_id: feeId,
        doc_id: docId,
        fee_type: feeData.fee_type,
        description: feeData.description,
        amount: feeData.amount,
        notes: feeData.notes,
        created_at: now
      }
    };
    
  } catch (error) {
    Logger.log('addDocumentFee error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Update a document fee
 */
function updateDocumentFee(feeId, updates) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const sheet = ss.getSheetByName('DocumentFees');
    
    if (!sheet) {
      return { ok: false, error: 'DocumentFees sheet not found' };
    }
    
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    const feeIdCol = headers.indexOf('fee_id');
    const docIdCol = headers.indexOf('doc_id');
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][feeIdCol] === feeId) {
        const docId = data[i][docIdCol];
        
        Object.keys(updates).forEach(key => {
          const col = headers.indexOf(key);
          if (col > -1 && key !== 'fee_id' && key !== 'doc_id' && key !== 'created_at') {
            sheet.getRange(i + 1, col + 1).setValue(updates[key]);
          }
        });
        
        recalculateDocumentTotals(docId);
        return { ok: true };
      }
    }
    
    return { ok: false, error: 'Fee not found: ' + feeId };
    
  } catch (error) {
    Logger.log('updateDocumentFee error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Delete a document fee
 */
function deleteDocumentFee(feeId) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    const sheet = ss.getSheetByName('DocumentFees');
    
    if (!sheet) {
      return { ok: false, error: 'DocumentFees sheet not found' };
    }
    
    const data = sheet.getDataRange().getValues();
    const headers = data[0];
    const feeIdCol = headers.indexOf('fee_id');
    const docIdCol = headers.indexOf('doc_id');
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][feeIdCol] === feeId) {
        const docId = data[i][docIdCol];
        sheet.deleteRow(i + 1);
        recalculateDocumentTotals(docId);
        return { ok: true };
      }
    }
    
    return { ok: false, error: 'Fee not found: ' + feeId };
    
  } catch (error) {
    Logger.log('deleteDocumentFee error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Recalculate document totals including fees
 */
function recalculateDocumentTotals(docId) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.opsSheetId);
    
    const lineItemsSheet = ss.getSheetByName('DocumentLineItems');
    const lineItemsData = lineItemsSheet.getDataRange().getValues();
    const liHeaders = lineItemsData[0];
    const liDocIdCol = liHeaders.indexOf('doc_id');
    const liTotalCol = liHeaders.indexOf('line_total');
    
    let lineItemsSubtotal = 0;
    for (let i = 1; i < lineItemsData.length; i++) {
      if (String(lineItemsData[i][liDocIdCol]) === String(docId)) {
        lineItemsSubtotal += Number(lineItemsData[i][liTotalCol]) || 0;
      }
    }
    
    const feesSheet = ss.getSheetByName('DocumentFees');
    let feesTotal = 0;
    if (feesSheet) {
      const feesData = feesSheet.getDataRange().getValues();
      const feeHeaders = feesData[0];
      const feeDocIdCol = feeHeaders.indexOf('doc_id');
      const feeAmountCol = feeHeaders.indexOf('amount');
      
      for (let i = 1; i < feesData.length; i++) {
        if (String(feesData[i][feeDocIdCol]) === String(docId)) {
          feesTotal += Number(feesData[i][feeAmountCol]) || 0;
        }
      }
    }
    
    const docsSheet = ss.getSheetByName('Documents');
    const docsData = docsSheet.getDataRange().getValues();
    const docHeaders = docsData[0];
    const docIdCol = docHeaders.indexOf('doc_id');
    
    for (let i = 1; i < docsData.length; i++) {
      if (String(docsData[i][docIdCol]) === String(docId)) {
        const subtotalCol = docHeaders.indexOf('subtotal');
        const discountAmountCol = docHeaders.indexOf('discount_amount');
        const taxAmountCol = docHeaders.indexOf('tax_amount');
        const totalCol = docHeaders.indexOf('total');
        const amountPaidCol = docHeaders.indexOf('amount_paid');
        const balanceDueCol = docHeaders.indexOf('balance_due');
        
        const subtotal = lineItemsSubtotal + feesTotal;
        const discountAmount = Number(docsData[i][discountAmountCol]) || 0;
        const taxAmount = Number(docsData[i][taxAmountCol]) || 0;
        const total = subtotal - discountAmount + taxAmount;
        const amountPaid = Number(docsData[i][amountPaidCol]) || 0;
        const balanceDue = total - amountPaid;
        
        if (subtotalCol > -1) docsSheet.getRange(i + 1, subtotalCol + 1).setValue(subtotal);
        if (totalCol > -1) docsSheet.getRange(i + 1, totalCol + 1).setValue(total);
        if (balanceDueCol > -1) docsSheet.getRange(i + 1, balanceDueCol + 1).setValue(balanceDue);
        
        return { ok: true };
      }
    }
    
    return { ok: false, error: 'Document not found' };
    
  } catch (error) {
    Logger.log('recalculateDocumentTotals error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

function testGetFeeTypes() {
  const result = getFeeTypes();
  Logger.log(JSON.stringify(result, null, 2));
}

function testGetCategoriesGrouped() {
  const result = getCategoriesGrouped();
  Logger.log(JSON.stringify(result, null, 2));
}

function testLineItemTypesLoad() {
  const config = getQuoteBuilderConfig();
  Logger.log('lineItemTypes count: ' + (config.lineItemTypes ? config.lineItemTypes.length : 'undefined'));
  Logger.log('lineItemTypes: ' + JSON.stringify(config.lineItemTypes));
}

function testFindLineItemTypesSheet() {
  const ss = SpreadsheetApp.openById(CONFIG.specSheetId);
  const sheets = ss.getSheets();
  sheets.forEach(s => Logger.log('Sheet: "' + s.getName() + '"'));
}

function testLineItemTypesData() {
  const ss = SpreadsheetApp.openById(CONFIG.specSheetId);
  const sheet = ss.getSheetByName('LineItemTypes');
  const data = sheet.getDataRange().getValues();
  Logger.log('Row count: ' + data.length);
  Logger.log('Headers: ' + JSON.stringify(data[0]));
  if (data.length > 1) {
    Logger.log('First data row: ' + JSON.stringify(data[1]));
    Logger.log('Active value: "' + data[1][data[0].indexOf('active')] + '" (type: ' + typeof data[1][data[0].indexOf('active')] + ')');
  }
}

function testDirectLoad() {
  const ss = SpreadsheetApp.openById(CONFIG.specSheetId);
  const litSheet = ss.getSheetByName('LineItemTypes');
  let lineItemTypes = [];
  if (litSheet) {
    const litData = litSheet.getDataRange().getValues();
    Logger.log('litData rows: ' + litData.length);
    if (litData.length > 1) {
      const headers = litData[0];
      for (let i = 1; i < litData.length; i++) {
        const lit = {};
        headers.forEach((h, col) => {
          lit[h] = litData[i][col];
        });
        if (lit.active === true || lit.active === 'TRUE') {
          lineItemTypes.push(lit);
        }
      }
    }
  }
  Logger.log('lineItemTypes count: ' + lineItemTypes.length);
  Logger.log('First type: ' + JSON.stringify(lineItemTypes[0]));
}

function testLineItemTypesLoad() {
  const config = getQuoteBuilderConfig();
  Logger.log('lineItemTypes count: ' + (config.lineItemTypes ? config.lineItemTypes.length : 'undefined'));
  Logger.log('lineItemTypes: ' + JSON.stringify(config.lineItemTypes));
}

function findDuplicateFunctions() {
  const scriptFiles = DriveApp.getFileById(ScriptApp.getScriptId());
  Logger.log('Script ID: ' + ScriptApp.getScriptId());
}

function updateMaterialsSheet() {
  Logger.log('Updating MaterialCost sheet...');
  
  const ss = SpreadsheetApp.openById(CONFIG.specSheetId);
  const sheet = ss.getSheetByName('MaterialCost');
  
  if (!sheet) {
    Logger.log('MaterialCost sheet not found!');
    return;
  }
  
  // Get current headers (row 2 has headers based on your CSV)
  const headerRange = sheet.getRange(2, 1, 1, sheet.getLastColumn());
  const headers = headerRange.getValues()[0];
  
  Logger.log('Current headers: ' + headers.join(', '));
  
  // Columns to add
  const newColumns = ['material_type', 'material_subtype', 'finish', 'dropdown_field'];
  
  // Find material_key column
  const materialKeyCol = headers.indexOf('material_key');
  
  if (materialKeyCol === -1) {
    Logger.log('material_key column not found!');
    return;
  }
  
  // Check which columns already exist
  const existingCols = new Set(headers.filter(h => h));
  let columnsAdded = 0;
  
  // Add columns after material_key (insert from right to left so positions don't shift)
  for (let i = newColumns.length - 1; i >= 0; i--) {
    const col = newColumns[i];
    if (!existingCols.has(col)) {
      const insertAfter = materialKeyCol + 1; // 1-indexed, after material_key
      sheet.insertColumnAfter(insertAfter);
      sheet.getRange(2, insertAfter + 1).setValue(col);
      Logger.log('Added column: ' + col);
      columnsAdded++;
    } else {
      Logger.log('Column already exists: ' + col);
    }
  }
  
  Logger.log('MaterialCost update complete. Columns added: ' + columnsAdded);
}

function updateLineItemTypesSheet() {
  Logger.log('Updating LineItemTypes sheet...');
  
  const ss = SpreadsheetApp.openById(CONFIG.specSheetId);
  const sheet = ss.getSheetByName('LineItemTypes');
  
  if (!sheet) {
    Logger.log('LineItemTypes sheet not found!');
    return;
  }
  
  // Get current headers (row 1)
  const headerRange = sheet.getRange(1, 1, 1, sheet.getLastColumn());
  const headers = headerRange.getValues()[0];
  
  Logger.log('Current headers: ' + headers.join(', '));
  
  // New columns to add
  const newColumns = [
    'modal_type',
    'requires_media',
    'requires_lamination',
    'default_media',
    'default_lamination',
    'labor_per_sqft',
    'labor_per_unit',
    'qualifier_question',
    'qualifier_options',
    'default_media_if_yes',
    'default_media_if_no'
  ];
  
  const existingCols = new Set(headers.filter(h => h));
  let columnsAdded = 0;
  
  newColumns.forEach(col => {
    if (!existingCols.has(col)) {
      const nextCol = sheet.getLastColumn() + 1;
      sheet.getRange(1, nextCol).setValue(col);
      Logger.log('Added column: ' + col);
      columnsAdded++;
    } else {
      Logger.log('Column already exists: ' + col);
    }
  });
  
  Logger.log('LineItemTypes update complete. Columns added: ' + columnsAdded);
}

function createLaborRatesSheet() {
  Logger.log('Creating LaborRates sheet...');
  
  const ss = SpreadsheetApp.openById(CONFIG.specSheetId);
  let sheet = ss.getSheetByName('LaborRates');
  
  if (sheet) {
    Logger.log('LaborRates sheet already exists');
    return;
  }
  
  // Create new sheet
  sheet = ss.insertSheet('LaborRates');
  
  // Define headers
  const headers = [
    'rate_key',
    'category_key',
    'type_key',
    'label',
    'labor_per_sqft',
    'labor_per_unit',
    'labor_per_hour',
    'min_charge',
    'notes',
    'active'
  ];
  
  // Set headers
  sheet.getRange(1, 1, 1, headers.length).setValues([headers]);
  
  // Format header row
  const headerRange = sheet.getRange(1, 1, 1, headers.length);
  headerRange.setFontWeight('bold');
  headerRange.setBackground('#1e293b');
  headerRange.setFontColor('#ffffff');
  
  // Add some default rates
  const defaultRates = [
    ['LABOR_VINYL_GRAPHICS', 'VINYL_GRAPHICS', '', 'Vinyl Graphics Labor', 2.00, '', '', 25, 'Standard graphics labor', true],
    ['LABOR_WRAP', 'FULL_WRAP', '', 'Wrap Labor', 4.00, '', '', 100, 'Full wrap labor', true],
    ['LABOR_PARTIAL_WRAP', 'PARTIAL_WRAP', '', 'Partial Wrap Labor', 3.50, '', '', 75, 'Partial wrap labor', true],
    ['LABOR_PPF', 'PPF', '', 'PPF Labor', 5.00, '', '', 150, 'PPF installation labor', true],
    ['LABOR_STICKER_KISS', 'STICKERS', 'KISS_CUT', 'Kiss Cut Labor', '', 0.15, '', 15, 'Per sticker', true],
    ['LABOR_STICKER_DIE', 'STICKERS', 'DIE_CUT', 'Die Cut Labor', '', 0.25, '', 20, 'Per sticker', true],
    ['LABOR_DESIGN', 'DESIGN_FEE', '', 'Design Labor', '', '', 90, 50, 'Per hour', true],
    ['LABOR_SIGNAGE', 'SIGNAGE', '', 'Signage Labor', 1.50, '', '', 25, 'Standard signage', true],
    ['LABOR_BANNER', 'BANNERS', '', 'Banner Labor', 1.00, '', '', 20, 'Banner production', true],
  ];
  
  sheet.getRange(2, 1, defaultRates.length, defaultRates[0].length).setValues(defaultRates);
  
  // Set column widths
  sheet.setColumnWidth(1, 180);
  sheet.setColumnWidth(2, 140);
  sheet.setColumnWidth(3, 140);
  sheet.setColumnWidth(4, 180);
  sheet.setColumnWidth(5, 100);
  sheet.setColumnWidth(6, 100);
  sheet.setColumnWidth(7, 100);
  sheet.setColumnWidth(8, 80);
  sheet.setColumnWidth(9, 200);
  sheet.setColumnWidth(10, 60);
  
  // Freeze header
  sheet.setFrozenRows(1);
  
  Logger.log('LaborRates sheet created with ' + defaultRates.length + ' default rates');
}

function populateMaterialTypes() {
  Logger.log('Populating material_type column...');
  
  const ss = SpreadsheetApp.openById(CONFIG.specSheetId);
  const sheet = ss.getSheetByName('MaterialCost');
  
  if (!sheet) {
    Logger.log('MaterialCost sheet not found!');
    return;
  }
  
  const data = sheet.getDataRange().getValues();
  const headers = data[1]; // Row 2 has headers
  
  const materialTypeCol = headers.indexOf('material_type');
  const materialSubtypeCol = headers.indexOf('material_subtype');
  const finishCol = headers.indexOf('finish');
  const dropdownFieldCol = headers.indexOf('dropdown_field');
  const materialKeyCol = headers.indexOf('material_key');
  
  Logger.log('Column positions - material_type: ' + materialTypeCol + ', material_subtype: ' + materialSubtypeCol + ', finish: ' + finishCol + ', dropdown_field: ' + dropdownFieldCol);
  
  if (materialTypeCol === -1) {
    Logger.log('material_type column not found!');
    return;
  }
  
  // Section header mappings
  const sectionMappings = {
    'VINYL': { type: 'MEDIA', subtype: '', dropdown: 'media' },
    'Lamination': { type: 'LAMINATION', subtype: '', dropdown: 'lamination' },
    'Transfer Tape': { type: 'TRANSFER_TAPE', subtype: '', dropdown: '' },
    'PPF': { type: 'PPF', subtype: '', dropdown: 'media' },
    'Stickers': { type: 'MEDIA', subtype: 'STICKER', dropdown: 'media' },
    'Banners': { type: 'MEDIA', subtype: 'BANNER', dropdown: 'media' },
    'DTF Apparel & Transfers': { type: 'APPAREL', subtype: 'DTF', dropdown: 'media' },
    'Wall Graphics': { type: 'MEDIA', subtype: 'WALL', dropdown: 'media' },
    'Window Perf': { type: 'MEDIA', subtype: 'WINDOW_PERF', dropdown: 'media' },
    'Window Cling': { type: 'MEDIA', subtype: 'WINDOW_CLING', dropdown: 'media' },
    'Magnets': { type: 'SUBSTRATE', subtype: 'MAGNET', dropdown: 'substrate' },
    'Foam Core': { type: 'SUBSTRATE', subtype: 'FOAM_CORE', dropdown: 'substrate' },
    'Yard Signs': { type: 'SUBSTRATE', subtype: 'YARD_SIGN', dropdown: 'substrate' }
  };
  
  // Check row 1 for VINYL section header
  let currentSection = null;
  if (data[0][0] && sectionMappings[data[0][0]]) {
    currentSection = sectionMappings[data[0][0]];
    Logger.log('Found initial section in row 1: ' + data[0][0] + ' -> ' + currentSection.type);
  }
  
  let updatedRows = 0;
  
  for (let i = 2; i < data.length; i++) { // Start after header row (row 2)
    const rowA = data[i][0]; // Column A value (Material name or section header)
    const materialKey = data[i][materialKeyCol + 2]; // Adjust for new columns inserted before it
    
    // Check if this is a section header (value in A, looks like a section name)
    if (rowA && sectionMappings[rowA]) {
      currentSection = sectionMappings[rowA];
      Logger.log('Found section: ' + rowA + ' -> ' + currentSection.type);
      continue;
    }
    
    // Skip empty rows or header-like rows
    if (!rowA || rowA === 'Material') {
      continue;
    }
    
    // If we have a material row and a current section
    if (currentSection) {
      const sheetRow = i + 1; // Convert to 1-indexed
      const materialLabel = String(rowA).toLowerCase();
      
      // Check if material_type is empty for this row
      const currentMaterialType = data[i][materialTypeCol];
      
      if (!currentMaterialType) {
        // Set material_type
        sheet.getRange(sheetRow, materialTypeCol + 1).setValue(currentSection.type);
        updatedRows++;
        
        // Set material_subtype - try to detect cast vs calendared
        if (materialSubtypeCol > -1) {
          let subtype = currentSection.subtype;
          
          // Auto-detect cast vs calendared from label
          if (materialLabel.includes('cast') || materialLabel.includes('1105') || materialLabel.includes('sw900') || materialLabel.includes('3951') || materialLabel.includes('dol 1') || materialLabel.includes('wrapcast')) {
            subtype = 'CAST';
          } else if (materialLabel.includes('calendar') || materialLabel.includes('651') || materialLabel.includes('2203') || materialLabel.includes('3205') || materialLabel.includes('sc 950') || materialLabel.includes('shield')) {
            subtype = 'CALENDARED';
          }
          
          if (subtype) {
            sheet.getRange(sheetRow, materialSubtypeCol + 1).setValue(subtype);
          }
        }
        
        // Set finish for laminations
        if (finishCol > -1 && currentSection.type === 'LAMINATION') {
          if (materialLabel.includes('matte')) {
            sheet.getRange(sheetRow, finishCol + 1).setValue('MATTE');
          } else if (materialLabel.includes('satin') || materialLabel.includes('luster')) {
            sheet.getRange(sheetRow, finishCol + 1).setValue('SATIN');
          } else if (materialLabel.includes('gloss')) {
            sheet.getRange(sheetRow, finishCol + 1).setValue('GLOSS');
          }
        }
        
        // Set dropdown_field
        if (dropdownFieldCol > -1 && currentSection.dropdown) {
          sheet.getRange(sheetRow, dropdownFieldCol + 1).setValue(currentSection.dropdown);
        }
        
        Logger.log('Updated row ' + sheetRow + ': ' + rowA + ' -> ' + currentSection.type);
      }
    }
  }
  
  Logger.log('Material types populated. Rows updated: ' + updatedRows);
}

function populateLineItemTypeDefaults() {
  Logger.log('Populating LineItemTypes defaults...');
  
  const ss = SpreadsheetApp.openById(CONFIG.specSheetId);
  const sheet = ss.getSheetByName('LineItemTypes');
  
  if (!sheet) {
    Logger.log('LineItemTypes sheet not found!');
    return;
  }
  
  const data = sheet.getDataRange().getValues();
  const headers = data[0];
  
  // Build column index map
  const colMap = {};
  headers.forEach((h, i) => colMap[h] = i);
  
  Logger.log('Columns found: ' + Object.keys(colMap).join(', '));
  
  // Define defaults for known types
  const typeDefaults = {
    'PRINTED_CUT_VINYL': {
      modal_type: 'VINYL_GRAPHICS',
      requires_media: true,
      requires_lamination: true,
      default_media: 'BRITELINE_2203_54',
      default_lamination: 'BRITELINE_CAL_SHIELD_54',
      labor_per_sqft: 2.00,
      qualifier_question: 'Requires Air Release?',
      qualifier_options: 'Yes|No',
      default_media_if_yes: 'AVERY_1105_54',
      default_media_if_no: 'BRITELINE_2203_54'
    },
    'WRAP_VINYL': {
      modal_type: 'VINYL_GRAPHICS',
      requires_media: true,
      requires_lamination: true,
      default_media: 'AVERY_1105_54',
      default_lamination: 'BRITELINE_CAST_MATTE_54',
      labor_per_sqft: 3.00
    },
    'PRINTED_WRAP_VINYL': {
      modal_type: 'VINYL_GRAPHICS',
      requires_media: true,
      requires_lamination: true,
      default_media: 'AVERY_1105_54',
      default_lamination: 'BRITELINE_CAST_MATTE_54',
      labor_per_sqft: 3.50
    },
    'CUT_VINYL': {
      modal_type: 'VINYL_GRAPHICS',
      requires_media: true,
      requires_lamination: false,
      default_media: 'ORACAL_651_24',
      labor_per_sqft: 1.50
    },
    'COMMERCIAL_FULL': {
      modal_type: 'WRAP',
      requires_media: true,
      requires_lamination: true,
      default_media: 'AVERY_1105_54',
      default_lamination: 'BRITELINE_CAST_MATTE_54',
      labor_per_sqft: 4.00
    },
    'COMMERCIAL_PARTIAL': {
      modal_type: 'WRAP',
      requires_media: true,
      requires_lamination: true,
      default_media: 'AVERY_1105_54',
      default_lamination: 'BRITELINE_CAST_MATTE_54',
      labor_per_sqft: 3.50
    },
    'COLOR_CHANGE_FULL': {
      modal_type: 'WRAP',
      requires_media: true,
      requires_lamination: false,
      default_media: 'AVERY_SW900_60',
      labor_per_sqft: 5.00
    },
    'COLOR_CHANGE_PARTIAL': {
      modal_type: 'WRAP',
      requires_media: true,
      requires_lamination: false,
      default_media: 'AVERY_SW900_60',
      labor_per_sqft: 4.50
    },
    'VAN_INSERTS': {
      modal_type: 'SIGNAGE',
      requires_media: true,
      requires_lamination: false,
      default_media: 'ORACAL_3551',
      labor_per_sqft: 2.00
    },
    'KISS_CUT': {
      modal_type: 'STICKERS',
      requires_media: true,
      requires_lamination: false,
      labor_per_unit: 0.15
    },
    'DIE_CUT': {
      modal_type: 'STICKERS',
      requires_media: true,
      requires_lamination: false,
      labor_per_unit: 0.25
    },
    'SHEET_LABELS': {
      modal_type: 'STICKERS',
      requires_media: true,
      requires_lamination: false,
      labor_per_unit: 0.10
    },
    'CORO_PLAST': {
      modal_type: 'SUBSTRATE',
      requires_media: false,
      requires_lamination: false,
      labor_per_sqft: 1.00
    },
    'MAX_METAL': {
      modal_type: 'SUBSTRATE',
      requires_media: false,
      requires_lamination: false,
      labor_per_sqft: 1.50
    },
    'FOAM_CORE': {
      modal_type: 'SUBSTRATE',
      requires_media: false,
      requires_lamination: false,
      labor_per_sqft: 1.00
    },
    'VERTICAL_FLUTE': {
      modal_type: 'YARD_SIGNS',
      requires_media: false,
      requires_lamination: false,
      labor_per_unit: 2.00
    },
    'HORIZONTAL_FLUTE': {
      modal_type: 'YARD_SIGNS',
      requires_media: false,
      requires_lamination: false,
      labor_per_unit: 2.00
    },
    'WITH_FRAME': {
      modal_type: 'A_FRAME',
      requires_media: false,
      requires_lamination: false,
      labor_per_unit: 5.00
    },
    'INSERT_ONLY': {
      modal_type: 'A_FRAME',
      requires_media: false,
      requires_lamination: false,
      labor_per_unit: 2.00
    },
    'FLAT_EMB': {
      modal_type: 'EMBROIDERY',
      requires_media: false,
      requires_lamination: false,
      labor_per_unit: 0.50
    },
    'CAP_EMB': {
      modal_type: 'EMBROIDERY',
      requires_media: false,
      requires_lamination: false,
      labor_per_unit: 1.00
    },
    'TRANSFER_BY_SIZE': {
      modal_type: 'APPAREL',
      requires_media: false,
      requires_lamination: false,
      labor_per_unit: 0.25
    },
    'GANG_SHEET': {
      modal_type: 'APPAREL',
      requires_media: false,
      requires_lamination: false,
      labor_per_sqft: 1.00
    },
    'LA MARZOCCO': {
      modal_type: 'DEFAULT',
      requires_media: false,
      requires_lamination: false,
      labor_per_unit: 50.00
    }
  };
  
  let updatedRows = 0;
  
  for (let i = 1; i < data.length; i++) {
    const typeKey = data[i][colMap['type_key']];
    
    if (typeKey && typeDefaults[typeKey]) {
      const defaults = typeDefaults[typeKey];
      const sheetRow = i + 1;
      let rowUpdated = false;
      
      Object.keys(defaults).forEach(field => {
        if (colMap[field] !== undefined) {
          const currentValue = data[i][colMap[field]];
          // Only update if empty
          if (currentValue === '' || currentValue === null || currentValue === undefined) {
            sheet.getRange(sheetRow, colMap[field] + 1).setValue(defaults[field]);
            rowUpdated = true;
          }
        }
      });
      
      if (rowUpdated) {
        Logger.log('Updated: ' + typeKey);
        updatedRows++;
      }
    }
  }
  
  Logger.log('LineItemTypes defaults populated. Rows updated: ' + updatedRows);
}

function fixMediaRows() {
  Logger.log('Fixing Media rows...');
  
  const ss = SpreadsheetApp.openById(CONFIG.specSheetId);
  const sheet = ss.getSheetByName('MaterialCost');
  const data = sheet.getDataRange().getValues();
  const headers = data[1];
  
  const materialTypeCol = headers.indexOf('material_type');
  const materialSubtypeCol = headers.indexOf('material_subtype');
  const dropdownFieldCol = headers.indexOf('dropdown_field');
  
  let updatedRows = 0;
  
  // Process rows 3-20 (the VINYL/Media section before Lamination)
  for (let i = 2; i < data.length; i++) {
    const rowA = data[i][0];
    
    // Stop when we hit Lamination section
    if (rowA === 'Lamination') {
      Logger.log('Reached Lamination section at row ' + (i + 1));
      break;
    }
    
    // Skip empty rows and section headers
    if (!rowA || rowA === 'VINYL') continue;
    
    const sheetRow = i + 1;
    const currentType = data[i][materialTypeCol];
    
    // Only update if material_type is empty
    if (!currentType) {
      const label = String(rowA).toLowerCase();
      
      // Set material_type
      sheet.getRange(sheetRow, materialTypeCol + 1).setValue('MEDIA');
      
      // Set material_subtype (cast vs calendared)
      if (materialSubtypeCol > -1) {
        if (label.includes('1105') || label.includes('sw900') || label.includes('3951') || label.includes('3551')) {
          sheet.getRange(sheetRow, materialSubtypeCol + 1).setValue('CAST');
        } else if (label.includes('2203') || label.includes('3205') || label.includes('651') || label.includes('2105')) {
          sheet.getRange(sheetRow, materialSubtypeCol + 1).setValue('CALENDARED');
        }
      }
      
      // Set dropdown_field
      sheet.getRange(sheetRow, dropdownFieldCol + 1).setValue('media');
      
      Logger.log('Updated: ' + rowA);
      updatedRows++;
    }
  }
  
  Logger.log('Media rows fixed. Rows updated: ' + updatedRows);
}

function generateMaterialKeys() {
  Logger.log('Generating material_key values...');
  
  const ss = SpreadsheetApp.openById(CONFIG.specSheetId);
  const sheet = ss.getSheetByName('MaterialCost');
  const data = sheet.getDataRange().getValues();
  const headers = data[1];
  
  const materialKeyCol = headers.indexOf('material_key');
  
  if (materialKeyCol === -1) {
    Logger.log('material_key column not found!');
    return;
  }
  
  let updatedRows = 0;
  
  for (let i = 2; i < data.length; i++) {
    const materialName = data[i][0];
    const existingKey = data[i][materialKeyCol];
    
    // Skip if no material name, is a section header, or already has a key
    if (!materialName || existingKey) continue;
    
    // Skip section headers (no other data in row typically)
    const sectionHeaders = ['VINYL', 'Lamination', 'Transfer Tape', 'PPF', 'Stickers', 'Banners', 
                           'DTF Apparel & Transfers', 'Wall Graphics', 'Window Perf', 'Window Cling', 
                           'Magnets', 'Foam Core', 'Yard Signs'];
    if (sectionHeaders.includes(materialName)) continue;
    
    // Generate key from material name
    let key = String(materialName)
      .toUpperCase()                          // Uppercase
      .replace(/®/g, '')                      // Remove ®
      .replace(/[""]/g, '')                   // Remove curly quotes
      .replace(/["']/g, '')                   // Remove straight quotes
      .replace(/\|/g, '_')                    // Replace | with _
      .replace(/\+/g, '_PLUS')                // Replace + with _PLUS
      .replace(/\s+/g, '_')                   // Replace spaces with _
      .replace(/[^A-Z0-9_]/g, '')             // Remove any other special chars
      .replace(/_+/g, '_')                    // Collapse multiple underscores
      .replace(/^_|_$/g, '');                 // Trim leading/trailing underscores
    
    if (key) {
      const sheetRow = i + 1;
      sheet.getRange(sheetRow, materialKeyCol + 1).setValue(key);
      Logger.log('Generated: ' + materialName + ' → ' + key);
      updatedRows++;
    }
  }
  
  Logger.log('Material keys generated. Rows updated: ' + updatedRows);
}function updateMaterialCheckboxColumns() {
  Logger.log('Updating MaterialCost checkbox columns...');
  
  const ss = SpreadsheetApp.openById(CONFIG.specSheetId);
  const sheet = ss.getSheetByName('MaterialCost');
  const headerRow = 2; // Row 2 has headers
  
  const headers = sheet.getRange(headerRow, 1, 1, sheet.getLastColumn()).getValues()[0];
  
  // Columns to ADD (missing type columns)
  const columnsToAdd = [
    'VERTICAL_FLUTE',
    'HORIZONTAL_FLUTE',
    'FLAT_EMB',
    'CAP_EMB',
    'TRANSFER_BY_SIZE',
    'GANG_SHEET'
  ];
  
  // Columns to REMOVE (category columns that have types - redundant)
  const columnsToRemove = [
    'YARD_SIGNS',   // Use VERTICAL_FLUTE, HORIZONTAL_FLUTE instead
    'STICKERS'      // Use KISS_CUT, DIE_CUT, SHEET_LABELS instead
  ];
  
  // First, add missing columns at the end
  let addedCount = 0;
  columnsToAdd.forEach(col => {
    if (!headers.includes(col)) {
      const nextCol = sheet.getLastColumn() + 1;
      sheet.getRange(headerRow, nextCol).setValue(col);
      
      // Set FALSE for all data rows
      const lastRow = sheet.getLastRow();
      if (lastRow > headerRow) {
        const numRows = lastRow - headerRow;
        const falseValues = Array(numRows).fill([false]);
        sheet.getRange(headerRow + 1, nextCol, numRows, 1).setValues(falseValues);
      }
      
      Logger.log('Added column: ' + col);
      addedCount++;
    } else {
      Logger.log('Column already exists: ' + col);
    }
  });
  
  // Now remove redundant columns (work backwards to avoid index shifting)
  // Re-fetch headers after adding
  const updatedHeaders = sheet.getRange(headerRow, 1, 1, sheet.getLastColumn()).getValues()[0];
  let removedCount = 0;
  
  for (let i = updatedHeaders.length - 1; i >= 0; i--) {
    if (columnsToRemove.includes(updatedHeaders[i])) {
      sheet.deleteColumn(i + 1);
      Logger.log('Removed column: ' + updatedHeaders[i]);
      removedCount++;
    }
  }
  
  Logger.log('Complete. Added: ' + addedCount + ', Removed: ' + removedCount);
}

function addSubstrateMaterials() {
  Logger.log('Adding substrate materials...');
  
  const ss = SpreadsheetApp.openById(CONFIG.specSheetId);
  const sheet = ss.getSheetByName('MaterialCost');
  const headers = sheet.getRange(2, 1, 1, sheet.getLastColumn()).getValues()[0];
  
  // Build column map
  const colMap = {};
  headers.forEach((h, i) => colMap[h] = i + 1);
  
  // Find the Foam Core row to insert after
  const data = sheet.getDataRange().getValues();
  let foamCoreRow = null;
  
  for (let i = 0; i < data.length; i++) {
    if (String(data[i][0]).includes('Foam Core Sheet')) {
      foamCoreRow = i + 1;
      break;
    }
  }
  
  if (!foamCoreRow) {
    Logger.log('Could not find Foam Core row');
    return;
  }
  
  Logger.log('Found Foam Core at row ' + foamCoreRow);
  
  // Insert 2 new rows after Foam Core
  sheet.insertRowsAfter(foamCoreRow, 2);
  
  // Max Metal row (foamCoreRow + 1)
  const maxMetalRow = foamCoreRow + 1;
  sheet.getRange(maxMetalRow, colMap['Material']).setValue("Max Metal Sheet 4'x8'");
  sheet.getRange(maxMetalRow, colMap['material_key']).setValue('MAX_METAL_4X8');
  sheet.getRange(maxMetalRow, colMap['material_type']).setValue('SUBSTRATE');
  sheet.getRange(maxMetalRow, colMap['material_subtype']).setValue('MAX_METAL');
  sheet.getRange(maxMetalRow, colMap['dropdown_field']).setValue('substrate');
  sheet.getRange(maxMetalRow, colMap['Roll Cost']).setValue(53.27);
  sheet.getRange(maxMetalRow, colMap['Width (ft)']).setValue(4);
  sheet.getRange(maxMetalRow, colMap['Length (ft)']).setValue(8);
  sheet.getRange(maxMetalRow, colMap['Total Sqft']).setValue(32);
  sheet.getRange(maxMetalRow, colMap['cost_sqft']).setValue(1.66);
  sheet.getRange(maxMetalRow, colMap['archived']).setValue(false);
  if (colMap['MAX_METAL']) sheet.getRange(maxMetalRow, colMap['MAX_METAL']).setValue(true);
  Logger.log('Added Max Metal');
  
  // Corrugated Plastic row (foamCoreRow + 2)
  const coroRow = foamCoreRow + 2;
  sheet.getRange(coroRow, colMap['Material']).setValue("Corrugated Plastic Panel 4'x8'");
  sheet.getRange(coroRow, colMap['material_key']).setValue('CORO_PLASTIC_4X8');
  sheet.getRange(coroRow, colMap['material_type']).setValue('SUBSTRATE');
  sheet.getRange(coroRow, colMap['material_subtype']).setValue('CORO_PLASTIC');
  sheet.getRange(coroRow, colMap['dropdown_field']).setValue('substrate');
  sheet.getRange(coroRow, colMap['Roll Cost']).setValue(9.62);
  sheet.getRange(coroRow, colMap['Width (ft)']).setValue(4);
  sheet.getRange(coroRow, colMap['Length (ft)']).setValue(8);
  sheet.getRange(coroRow, colMap['Total Sqft']).setValue(32);
  sheet.getRange(coroRow, colMap['cost_sqft']).setValue(0.30);
  sheet.getRange(coroRow, colMap['archived']).setValue(false);
  if (colMap['CORO_PLAST']) sheet.getRange(coroRow, colMap['CORO_PLAST']).setValue(true);
  if (colMap['VERTICAL_FLUTE']) sheet.getRange(coroRow, colMap['VERTICAL_FLUTE']).setValue(true);
  if (colMap['HORIZONTAL_FLUTE']) sheet.getRange(coroRow, colMap['HORIZONTAL_FLUTE']).setValue(true);
  Logger.log('Added Corrugated Plastic');
  
  // Update Foam Core row with proper checkboxes
  if (colMap['FOAM_CORE']) sheet.getRange(foamCoreRow, colMap['FOAM_CORE']).setValue(true);
  
  Logger.log('Substrates added and connected to types');
}

/**
 * Get materials for a category (all types within that category)
 */
function getMaterialsForCategory(categoryKey) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.specSheetId);
    const sheet = ss.getSheetByName('MaterialCost');
    
    if (!sheet) {
      return { ok: false, error: 'MaterialCost sheet not found' };
    }
    
    const data = sheet.getDataRange().getValues();
    const headers = data[1]; // Row 2 has headers
    
    // Build column map
    const colMap = {};
    headers.forEach((h, i) => colMap[h] = i);
    
    // Get all types for this category
    const typesSheet = ss.getSheetByName('LineItemTypes');
    const typesData = typesSheet.getDataRange().getValues();
    const typeKeys = [];
    
    for (let i = 1; i < typesData.length; i++) {
      if (typesData[i][1] === categoryKey) { // category_key column
        typeKeys.push(typesData[i][0]); // type_key column
      }
    }
    
    // Filter materials that have any of these type columns checked
    const materials = [];
    
    for (let i = 2; i < data.length; i++) {
      const row = data[i];
      const materialKey = row[colMap['material_key']];
      
      if (!materialKey) continue;
      if (row[colMap['archived']] === true || row[colMap['archived']] === 'TRUE') continue;
      
      // Check if any type column is TRUE for this material
      let hasMatch = false;
      for (const typeKey of typeKeys) {
        if (colMap[typeKey] !== undefined && (row[colMap[typeKey]] === true || row[colMap[typeKey]] === 'TRUE')) {
          hasMatch = true;
          break;
        }
      }
      
      if (hasMatch) {
        const material = {};
        headers.forEach((h, col) => {
          material[h] = row[col];
        });
        materials.push(material);
      }
    }
    
    return { ok: true, materials: materials };
    
  } catch (error) {
    Logger.log('getMaterialsForCategory error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}

/**
 * Get materials for a specific type (filtered by type checkbox column)
 */
function getMaterialsForType(typeKey) {
  try {
    const ss = SpreadsheetApp.openById(CONFIG.specSheetId);
    const sheet = ss.getSheetByName('MaterialCost');
    
    if (!sheet) {
      return { ok: false, error: 'MaterialCost sheet not found' };
    }
    
    const data = sheet.getDataRange().getValues();
    const headers = data[1]; // Row 2 has headers
    
    // Build column map
    const colMap = {};
    headers.forEach((h, i) => colMap[h] = i);
    
    // Check if type column exists
    if (colMap[typeKey] === undefined) {
      Logger.log('Type column not found: ' + typeKey);
      return { ok: true, materials: [] };
    }
    
    const materials = [];
    
    for (let i = 2; i < data.length; i++) {
      const row = data[i];
      const materialKey = row[colMap['material_key']];
      
      if (!materialKey) continue;
      if (row[colMap['archived']] === true || row[colMap['archived']] === 'TRUE') continue;
      
      // Check if this type column is TRUE
      if (row[colMap[typeKey]] === true || row[colMap[typeKey]] === 'TRUE') {
        const material = {};
        headers.forEach((h, col) => {
          material[h] = row[col];
        });
        materials.push(material);
      }
    }
    
    Logger.log('getMaterialsForType ' + typeKey + ': found ' + materials.length + ' materials');
    return { ok: true, materials: materials };
    
  } catch (error) {
    Logger.log('getMaterialsForType error: ' + error.toString());
    return { ok: false, error: error.toString() };
  }
}